/* tslint:disable */
/* eslint-disable */
//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v13.11.3.0 (NJsonSchema v10.4.4.0 (Newtonsoft.Json v11.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------
// ReSharper disable InconsistentNaming

import { AbpServiceBase, request } from './service-base';

export class AbpServiceProxy extends AbpServiceBase {
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string) {
        super();
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param includeTypes (optional) 
     * @return Success
     */
    apiDefinition
    (includeTypes
    : boolean | undefined 
        ,): Promise<ApplicationApiDescriptionModel> {
        let url_ = this.baseUrl + "/api/abp/api-definition?";
        if (includeTypes === null)
            throw new Error("The parameter 'includeTypes' cannot be null.");
        else if (includeTypes !== undefined)
            url_ += "IncludeTypes=" + encodeURIComponent("" + includeTypes) + "&";
        url_ = url_.replace(/[?&]$/, "");

                return request({
                                    method: "GET",
                    url: url_,
                    header: {
                                                "Accept": "text/plain"
                            },
                }).catch((_error: any) => {
            throw _error;
        }).then((_response) => {
            return this.processApiDefinition(_response);
        });
    }

    protected processApiDefinition(response): Promise<ApplicationApiDescriptionModel> {
        const status = response.status || response.statusCode;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText.result || _responseText;
            result200 = ApplicationApiDescriptionModel.fromJS(resultData200, _mappings);
            return result200;
        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText.result || _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403, _mappings);
            return throwException("Forbidden", status, _responseText, _headers, result403);
        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText.result || _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401, _mappings);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText.result || _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400, _mappings);
            return throwException("Bad Request", status, _responseText, _headers, result400);
        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText.result || _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404, _mappings);
            return throwException("Not Found", status, _responseText, _headers, result404);
        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText.result || _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501, _mappings);
            return throwException("Server Error", status, _responseText, _headers, result501);
        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText.result || _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500, _mappings);
            return throwException("Server Error", status, _responseText, _headers, result500);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ApplicationApiDescriptionModel>(<any>null);
    }

    /**
     * @return Success
     */
    applicationConfiguration
    ( ): Promise<ApplicationConfigurationDto> {
        let url_ = this.baseUrl + "/api/abp/application-configuration";
        url_ = url_.replace(/[?&]$/, "");

                return request({
                                    method: "GET",
                    url: url_,
                    header: {
                                                "Accept": "text/plain"
                            },
                }).catch((_error: any) => {
            throw _error;
        }).then((_response) => {
            return this.processApplicationConfiguration(_response);
        });
    }

    protected processApplicationConfiguration(response): Promise<ApplicationConfigurationDto> {
        const status = response.status || response.statusCode;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText.result || _responseText;
            result200 = ApplicationConfigurationDto.fromJS(resultData200, _mappings);
            return result200;
        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText.result || _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403, _mappings);
            return throwException("Forbidden", status, _responseText, _headers, result403);
        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText.result || _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401, _mappings);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText.result || _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400, _mappings);
            return throwException("Bad Request", status, _responseText, _headers, result400);
        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText.result || _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404, _mappings);
            return throwException("Not Found", status, _responseText, _headers, result404);
        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText.result || _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501, _mappings);
            return throwException("Server Error", status, _responseText, _headers, result501);
        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText.result || _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500, _mappings);
            return throwException("Server Error", status, _responseText, _headers, result500);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ApplicationConfigurationDto>(<any>null);
    }
}

export class TenantsServiceProxy extends AbpServiceBase {
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string) {
        super();
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @return Success
     */
    byName
    (name
    : string 
        ,): Promise<FindTenantResultDto> {
        let url_ = this.baseUrl + "/api/abp/multi-tenancy/tenants/by-name/{name}";
        if (name === undefined || name === null)
            throw new Error("The parameter 'name' must be defined.");
        url_ = url_.replace("{name}", encodeURIComponent("" + name));
        url_ = url_.replace(/[?&]$/, "");

                return request({
                                    method: "GET",
                    url: url_,
                    header: {
                                                "Accept": "text/plain"
                            },
                }).catch((_error: any) => {
            throw _error;
        }).then((_response) => {
            return this.processByName(_response);
        });
    }

    protected processByName(response): Promise<FindTenantResultDto> {
        const status = response.status || response.statusCode;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText.result || _responseText;
            result200 = FindTenantResultDto.fromJS(resultData200, _mappings);
            return result200;
        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText.result || _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403, _mappings);
            return throwException("Forbidden", status, _responseText, _headers, result403);
        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText.result || _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401, _mappings);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText.result || _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400, _mappings);
            return throwException("Bad Request", status, _responseText, _headers, result400);
        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText.result || _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404, _mappings);
            return throwException("Not Found", status, _responseText, _headers, result404);
        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText.result || _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501, _mappings);
            return throwException("Server Error", status, _responseText, _headers, result501);
        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText.result || _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500, _mappings);
            return throwException("Server Error", status, _responseText, _headers, result500);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<FindTenantResultDto>(<any>null);
    }

    /**
     * @return Success
     */
    byId
    (id
    : string 
        ,): Promise<FindTenantResultDto> {
        let url_ = this.baseUrl + "/api/abp/multi-tenancy/tenants/by-id/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

                return request({
                                    method: "GET",
                    url: url_,
                    header: {
                                                "Accept": "text/plain"
                            },
                }).catch((_error: any) => {
            throw _error;
        }).then((_response) => {
            return this.processById(_response);
        });
    }

    protected processById(response): Promise<FindTenantResultDto> {
        const status = response.status || response.statusCode;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText.result || _responseText;
            result200 = FindTenantResultDto.fromJS(resultData200, _mappings);
            return result200;
        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText.result || _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403, _mappings);
            return throwException("Forbidden", status, _responseText, _headers, result403);
        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText.result || _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401, _mappings);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText.result || _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400, _mappings);
            return throwException("Bad Request", status, _responseText, _headers, result400);
        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText.result || _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404, _mappings);
            return throwException("Not Found", status, _responseText, _headers, result404);
        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText.result || _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501, _mappings);
            return throwException("Server Error", status, _responseText, _headers, result501);
        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText.result || _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500, _mappings);
            return throwException("Server Error", status, _responseText, _headers, result500);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<FindTenantResultDto>(<any>null);
    }

    /**
     * @return Success
     */
    defaultConnectionStringGet
    (id
    : string 
        ,): Promise<string> {
        let url_ = this.baseUrl + "/api/multi-tenancy/tenants/{id}/default-connection-string";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

                return request({
                                    method: "GET",
                    url: url_,
                    header: {
                                                "Accept": "text/plain"
                            },
                }).catch((_error: any) => {
            throw _error;
        }).then((_response) => {
            return this.processDefaultConnectionStringGet(_response);
        });
    }

    protected processDefaultConnectionStringGet(response): Promise<string> {
        const status = response.status || response.statusCode;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText.result || _responseText;
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return result200;
        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText.result || _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403, _mappings);
            return throwException("Forbidden", status, _responseText, _headers, result403);
        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText.result || _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401, _mappings);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText.result || _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400, _mappings);
            return throwException("Bad Request", status, _responseText, _headers, result400);
        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText.result || _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404, _mappings);
            return throwException("Not Found", status, _responseText, _headers, result404);
        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText.result || _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501, _mappings);
            return throwException("Server Error", status, _responseText, _headers, result501);
        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText.result || _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500, _mappings);
            return throwException("Server Error", status, _responseText, _headers, result500);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<string>(<any>null);
    }

    /**
     * @param defaultConnectionString (optional) 
     * @return Success
     */
    defaultConnectionStringPut
    (id
    : string
        , defaultConnectionString
    : string | undefined 
        ,): Promise<void> {
        let url_ = this.baseUrl + "/api/multi-tenancy/tenants/{id}/default-connection-string?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (defaultConnectionString === null)
            throw new Error("The parameter 'defaultConnectionString' cannot be null.");
        else if (defaultConnectionString !== undefined)
            url_ += "defaultConnectionString=" + encodeURIComponent("" + defaultConnectionString) + "&";
        url_ = url_.replace(/[?&]$/, "");

                return request({
                                    method: "PUT",
                    url: url_,
                    header: {
                                            },
                }).catch((_error: any) => {
            throw _error;
        }).then((_response) => {
            return this.processDefaultConnectionStringPut(_response);
        });
    }

    protected processDefaultConnectionStringPut(response): Promise<void> {
        const status = response.status || response.statusCode;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(<any>null);
        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText.result || _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403, _mappings);
            return throwException("Forbidden", status, _responseText, _headers, result403);
        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText.result || _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401, _mappings);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText.result || _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400, _mappings);
            return throwException("Bad Request", status, _responseText, _headers, result400);
        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText.result || _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404, _mappings);
            return throwException("Not Found", status, _responseText, _headers, result404);
        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText.result || _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501, _mappings);
            return throwException("Server Error", status, _responseText, _headers, result501);
        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText.result || _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500, _mappings);
            return throwException("Server Error", status, _responseText, _headers, result500);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(<any>null);
    }

    /**
     * @return Success
     */
    defaultConnectionStringDelete
    (id
    : string 
        ,): Promise<void> {
        let url_ = this.baseUrl + "/api/multi-tenancy/tenants/{id}/default-connection-string";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

                return request({
                                    method: "DELETE",
                    url: url_,
                    header: {
                                            },
                }).catch((_error: any) => {
            throw _error;
        }).then((_response) => {
            return this.processDefaultConnectionStringDelete(_response);
        });
    }

    protected processDefaultConnectionStringDelete(response): Promise<void> {
        const status = response.status || response.statusCode;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(<any>null);
        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText.result || _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403, _mappings);
            return throwException("Forbidden", status, _responseText, _headers, result403);
        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText.result || _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401, _mappings);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText.result || _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400, _mappings);
            return throwException("Bad Request", status, _responseText, _headers, result400);
        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText.result || _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404, _mappings);
            return throwException("Not Found", status, _responseText, _headers, result404);
        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText.result || _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501, _mappings);
            return throwException("Server Error", status, _responseText, _headers, result501);
        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText.result || _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500, _mappings);
            return throwException("Server Error", status, _responseText, _headers, result500);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(<any>null);
    }
}

export class AccountServiceProxy extends AbpServiceBase {
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string) {
        super();
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    register
    (body
    : RegisterDto | undefined 
        ,): Promise<IdentityUserDto> {
        let url_ = this.baseUrl + "/api/account/register";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

                return request({
                            data: content_,
                                    method: "POST",
                    url: url_,
                    header: {
                                        "Content-Type": "application/json",
                                        "Accept": "text/plain"
                            },
                }).catch((_error: any) => {
            throw _error;
        }).then((_response) => {
            return this.processRegister(_response);
        });
    }

    protected processRegister(response): Promise<IdentityUserDto> {
        const status = response.status || response.statusCode;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText.result || _responseText;
            result200 = IdentityUserDto.fromJS(resultData200, _mappings);
            return result200;
        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText.result || _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403, _mappings);
            return throwException("Forbidden", status, _responseText, _headers, result403);
        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText.result || _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401, _mappings);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText.result || _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400, _mappings);
            return throwException("Bad Request", status, _responseText, _headers, result400);
        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText.result || _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404, _mappings);
            return throwException("Not Found", status, _responseText, _headers, result404);
        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText.result || _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501, _mappings);
            return throwException("Server Error", status, _responseText, _headers, result501);
        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText.result || _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500, _mappings);
            return throwException("Server Error", status, _responseText, _headers, result500);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<IdentityUserDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    sendPasswordResetCode
    (body
    : SendPasswordResetCodeDto | undefined 
        ,): Promise<void> {
        let url_ = this.baseUrl + "/api/account/send-password-reset-code";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

                return request({
                            data: content_,
                                    method: "POST",
                    url: url_,
                    header: {
                                        "Content-Type": "application/json",
                                    },
                }).catch((_error: any) => {
            throw _error;
        }).then((_response) => {
            return this.processSendPasswordResetCode(_response);
        });
    }

    protected processSendPasswordResetCode(response): Promise<void> {
        const status = response.status || response.statusCode;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(<any>null);
        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText.result || _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403, _mappings);
            return throwException("Forbidden", status, _responseText, _headers, result403);
        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText.result || _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401, _mappings);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText.result || _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400, _mappings);
            return throwException("Bad Request", status, _responseText, _headers, result400);
        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText.result || _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404, _mappings);
            return throwException("Not Found", status, _responseText, _headers, result404);
        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText.result || _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501, _mappings);
            return throwException("Server Error", status, _responseText, _headers, result501);
        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText.result || _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500, _mappings);
            return throwException("Server Error", status, _responseText, _headers, result500);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    resetPassword
    (body
    : ResetPasswordDto | undefined 
        ,): Promise<void> {
        let url_ = this.baseUrl + "/api/account/reset-password";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

                return request({
                            data: content_,
                                    method: "POST",
                    url: url_,
                    header: {
                                        "Content-Type": "application/json",
                                    },
                }).catch((_error: any) => {
            throw _error;
        }).then((_response) => {
            return this.processResetPassword(_response);
        });
    }

    protected processResetPassword(response): Promise<void> {
        const status = response.status || response.statusCode;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(<any>null);
        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText.result || _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403, _mappings);
            return throwException("Forbidden", status, _responseText, _headers, result403);
        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText.result || _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401, _mappings);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText.result || _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400, _mappings);
            return throwException("Bad Request", status, _responseText, _headers, result400);
        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText.result || _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404, _mappings);
            return throwException("Not Found", status, _responseText, _headers, result404);
        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText.result || _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501, _mappings);
            return throwException("Server Error", status, _responseText, _headers, result501);
        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText.result || _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500, _mappings);
            return throwException("Server Error", status, _responseText, _headers, result500);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    login
    (body
    : UserLoginInfo | undefined 
        ,): Promise<AbpLoginResult> {
        let url_ = this.baseUrl + "/api/account/login";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

                return request({
                            data: content_,
                                    method: "POST",
                    url: url_,
                    header: {
                                        "Content-Type": "application/json",
                                        "Accept": "text/plain"
                            },
                }).catch((_error: any) => {
            throw _error;
        }).then((_response) => {
            return this.processLogin(_response);
        });
    }

    protected processLogin(response): Promise<AbpLoginResult> {
        const status = response.status || response.statusCode;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText.result || _responseText;
            result200 = AbpLoginResult.fromJS(resultData200, _mappings);
            return result200;
        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText.result || _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403, _mappings);
            return throwException("Forbidden", status, _responseText, _headers, result403);
        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText.result || _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401, _mappings);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText.result || _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400, _mappings);
            return throwException("Bad Request", status, _responseText, _headers, result400);
        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText.result || _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404, _mappings);
            return throwException("Not Found", status, _responseText, _headers, result404);
        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText.result || _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501, _mappings);
            return throwException("Server Error", status, _responseText, _headers, result501);
        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText.result || _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500, _mappings);
            return throwException("Server Error", status, _responseText, _headers, result500);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<AbpLoginResult>(<any>null);
    }

    /**
     * @return Success
     */
    logout
    ( ): Promise<void> {
        let url_ = this.baseUrl + "/api/account/logout";
        url_ = url_.replace(/[?&]$/, "");

                return request({
                                    method: "GET",
                    url: url_,
                    header: {
                                            },
                }).catch((_error: any) => {
            throw _error;
        }).then((_response) => {
            return this.processLogout(_response);
        });
    }

    protected processLogout(response): Promise<void> {
        const status = response.status || response.statusCode;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(<any>null);
        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText.result || _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403, _mappings);
            return throwException("Forbidden", status, _responseText, _headers, result403);
        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText.result || _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401, _mappings);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText.result || _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400, _mappings);
            return throwException("Bad Request", status, _responseText, _headers, result400);
        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText.result || _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404, _mappings);
            return throwException("Not Found", status, _responseText, _headers, result404);
        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText.result || _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501, _mappings);
            return throwException("Server Error", status, _responseText, _headers, result501);
        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText.result || _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500, _mappings);
            return throwException("Server Error", status, _responseText, _headers, result500);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    checkPassword
    (body
    : UserLoginInfo | undefined 
        ,): Promise<AbpLoginResult> {
        let url_ = this.baseUrl + "/api/account/check-password";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

                return request({
                            data: content_,
                                    method: "POST",
                    url: url_,
                    header: {
                                        "Content-Type": "application/json",
                                        "Accept": "text/plain"
                            },
                }).catch((_error: any) => {
            throw _error;
        }).then((_response) => {
            return this.processCheckPassword(_response);
        });
    }

    protected processCheckPassword(response): Promise<AbpLoginResult> {
        const status = response.status || response.statusCode;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText.result || _responseText;
            result200 = AbpLoginResult.fromJS(resultData200, _mappings);
            return result200;
        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText.result || _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403, _mappings);
            return throwException("Forbidden", status, _responseText, _headers, result403);
        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText.result || _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401, _mappings);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText.result || _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400, _mappings);
            return throwException("Bad Request", status, _responseText, _headers, result400);
        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText.result || _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404, _mappings);
            return throwException("Not Found", status, _responseText, _headers, result404);
        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText.result || _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501, _mappings);
            return throwException("Server Error", status, _responseText, _headers, result501);
        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText.result || _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500, _mappings);
            return throwException("Server Error", status, _responseText, _headers, result500);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<AbpLoginResult>(<any>null);
    }
}

export class AppServiceProxy extends AbpServiceBase {
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string) {
        super();
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    accountPost
    (body
    : AccountCreateUpdateDto | undefined 
        ,): Promise<AccountDto> {
        let url_ = this.baseUrl + "/api/app/account";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

                return request({
                            data: content_,
                                    method: "POST",
                    url: url_,
                    header: {
                                        "Content-Type": "application/json",
                                        "Accept": "text/plain"
                            },
                }).catch((_error: any) => {
            throw _error;
        }).then((_response) => {
            return this.processAccountPost(_response);
        });
    }

    protected processAccountPost(response): Promise<AccountDto> {
        const status = response.status || response.statusCode;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText.result || _responseText;
            result200 = AccountDto.fromJS(resultData200, _mappings);
            return result200;
        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText.result || _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403, _mappings);
            return throwException("Forbidden", status, _responseText, _headers, result403);
        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText.result || _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401, _mappings);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText.result || _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400, _mappings);
            return throwException("Bad Request", status, _responseText, _headers, result400);
        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText.result || _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404, _mappings);
            return throwException("Not Found", status, _responseText, _headers, result404);
        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText.result || _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501, _mappings);
            return throwException("Server Error", status, _responseText, _headers, result501);
        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText.result || _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500, _mappings);
            return throwException("Server Error", status, _responseText, _headers, result500);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<AccountDto>(<any>null);
    }

    /**
     * @param title (optional) 
     * @param includeInTotals (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    accountGet
    (title
    : string | undefined
        , includeInTotals
    : boolean | undefined
        , skipCount
    : number | undefined
        , maxResultCount
    : number | undefined 
        ,): Promise<PagedResultDto_1OfOfAccountDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null> {
        let url_ = this.baseUrl + "/api/app/account?";
        if (title === null)
            throw new Error("The parameter 'title' cannot be null.");
        else if (title !== undefined)
            url_ += "Title=" + encodeURIComponent("" + title) + "&";
        if (includeInTotals === null)
            throw new Error("The parameter 'includeInTotals' cannot be null.");
        else if (includeInTotals !== undefined)
            url_ += "IncludeInTotals=" + encodeURIComponent("" + includeInTotals) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

                return request({
                                    method: "GET",
                    url: url_,
                    header: {
                                                "Accept": "text/plain"
                            },
                }).catch((_error: any) => {
            throw _error;
        }).then((_response) => {
            return this.processAccountGet(_response);
        });
    }

    protected processAccountGet(response): Promise<PagedResultDto_1OfOfAccountDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null> {
        const status = response.status || response.statusCode;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText.result || _responseText;
            result200 = PagedResultDto_1OfOfAccountDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null.fromJS(resultData200, _mappings);
            return result200;
        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText.result || _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403, _mappings);
            return throwException("Forbidden", status, _responseText, _headers, result403);
        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText.result || _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401, _mappings);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText.result || _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400, _mappings);
            return throwException("Bad Request", status, _responseText, _headers, result400);
        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText.result || _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404, _mappings);
            return throwException("Not Found", status, _responseText, _headers, result404);
        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText.result || _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501, _mappings);
            return throwException("Server Error", status, _responseText, _headers, result501);
        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText.result || _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500, _mappings);
            return throwException("Server Error", status, _responseText, _headers, result500);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<PagedResultDto_1OfOfAccountDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    accountPut
    (id
    : string
        , body
    : AccountCreateUpdateDto | undefined 
        ,): Promise<AccountDto> {
        let url_ = this.baseUrl + "/api/app/account/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

                return request({
                            data: content_,
                                    method: "PUT",
                    url: url_,
                    header: {
                                        "Content-Type": "application/json",
                                        "Accept": "text/plain"
                            },
                }).catch((_error: any) => {
            throw _error;
        }).then((_response) => {
            return this.processAccountPut(_response);
        });
    }

    protected processAccountPut(response): Promise<AccountDto> {
        const status = response.status || response.statusCode;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText.result || _responseText;
            result200 = AccountDto.fromJS(resultData200, _mappings);
            return result200;
        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText.result || _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403, _mappings);
            return throwException("Forbidden", status, _responseText, _headers, result403);
        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText.result || _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401, _mappings);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText.result || _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400, _mappings);
            return throwException("Bad Request", status, _responseText, _headers, result400);
        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText.result || _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404, _mappings);
            return throwException("Not Found", status, _responseText, _headers, result404);
        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText.result || _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501, _mappings);
            return throwException("Server Error", status, _responseText, _headers, result501);
        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText.result || _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500, _mappings);
            return throwException("Server Error", status, _responseText, _headers, result500);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<AccountDto>(<any>null);
    }

    /**
     * @return Success
     */
    accountGet
    (id
    : string 
        ,): Promise<AccountDto> {
        let url_ = this.baseUrl + "/api/app/account/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

                return request({
                                    method: "GET",
                    url: url_,
                    header: {
                                                "Accept": "text/plain"
                            },
                }).catch((_error: any) => {
            throw _error;
        }).then((_response) => {
            return this.processAccountGet(_response);
        });
    }

    protected processAccountGet(response): Promise<AccountDto> {
        const status = response.status || response.statusCode;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText.result || _responseText;
            result200 = AccountDto.fromJS(resultData200, _mappings);
            return result200;
        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText.result || _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403, _mappings);
            return throwException("Forbidden", status, _responseText, _headers, result403);
        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText.result || _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401, _mappings);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText.result || _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400, _mappings);
            return throwException("Bad Request", status, _responseText, _headers, result400);
        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText.result || _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404, _mappings);
            return throwException("Not Found", status, _responseText, _headers, result404);
        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText.result || _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501, _mappings);
            return throwException("Server Error", status, _responseText, _headers, result501);
        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText.result || _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500, _mappings);
            return throwException("Server Error", status, _responseText, _headers, result500);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<AccountDto>(<any>null);
    }

    /**
     * @return Success
     */
    accountDelete
    (id
    : string 
        ,): Promise<void> {
        let url_ = this.baseUrl + "/api/app/account/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

                return request({
                                    method: "DELETE",
                    url: url_,
                    header: {
                                            },
                }).catch((_error: any) => {
            throw _error;
        }).then((_response) => {
            return this.processAccountDelete(_response);
        });
    }

    protected processAccountDelete(response): Promise<void> {
        const status = response.status || response.statusCode;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(<any>null);
        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText.result || _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403, _mappings);
            return throwException("Forbidden", status, _responseText, _headers, result403);
        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText.result || _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401, _mappings);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText.result || _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400, _mappings);
            return throwException("Bad Request", status, _responseText, _headers, result400);
        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText.result || _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404, _mappings);
            return throwException("Not Found", status, _responseText, _headers, result404);
        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText.result || _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501, _mappings);
            return throwException("Server Error", status, _responseText, _headers, result501);
        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText.result || _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500, _mappings);
            return throwException("Server Error", status, _responseText, _headers, result500);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    categoryPost
    (body
    : CategoryCreateUpdateDto | undefined 
        ,): Promise<CategoryDto> {
        let url_ = this.baseUrl + "/api/app/category";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

                return request({
                            data: content_,
                                    method: "POST",
                    url: url_,
                    header: {
                                        "Content-Type": "application/json",
                                        "Accept": "text/plain"
                            },
                }).catch((_error: any) => {
            throw _error;
        }).then((_response) => {
            return this.processCategoryPost(_response);
        });
    }

    protected processCategoryPost(response): Promise<CategoryDto> {
        const status = response.status || response.statusCode;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText.result || _responseText;
            result200 = CategoryDto.fromJS(resultData200, _mappings);
            return result200;
        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText.result || _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403, _mappings);
            return throwException("Forbidden", status, _responseText, _headers, result403);
        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText.result || _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401, _mappings);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText.result || _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400, _mappings);
            return throwException("Bad Request", status, _responseText, _headers, result400);
        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText.result || _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404, _mappings);
            return throwException("Not Found", status, _responseText, _headers, result404);
        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText.result || _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501, _mappings);
            return throwException("Server Error", status, _responseText, _headers, result501);
        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText.result || _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500, _mappings);
            return throwException("Server Error", status, _responseText, _headers, result500);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<CategoryDto>(<any>null);
    }

    /**
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @param sorting (optional) 
     * @return Success
     */
    categoryGet
    (skipCount
    : number | undefined
        , maxResultCount
    : number | undefined
        , sorting
    : string | undefined 
        ,): Promise<PagedResultDto_1OfOfCategoryDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null> {
        let url_ = this.baseUrl + "/api/app/category?";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        url_ = url_.replace(/[?&]$/, "");

                return request({
                                    method: "GET",
                    url: url_,
                    header: {
                                                "Accept": "text/plain"
                            },
                }).catch((_error: any) => {
            throw _error;
        }).then((_response) => {
            return this.processCategoryGet(_response);
        });
    }

    protected processCategoryGet(response): Promise<PagedResultDto_1OfOfCategoryDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null> {
        const status = response.status || response.statusCode;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText.result || _responseText;
            result200 = PagedResultDto_1OfOfCategoryDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null.fromJS(resultData200, _mappings);
            return result200;
        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText.result || _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403, _mappings);
            return throwException("Forbidden", status, _responseText, _headers, result403);
        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText.result || _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401, _mappings);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText.result || _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400, _mappings);
            return throwException("Bad Request", status, _responseText, _headers, result400);
        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText.result || _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404, _mappings);
            return throwException("Not Found", status, _responseText, _headers, result404);
        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText.result || _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501, _mappings);
            return throwException("Server Error", status, _responseText, _headers, result501);
        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText.result || _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500, _mappings);
            return throwException("Server Error", status, _responseText, _headers, result500);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<PagedResultDto_1OfOfCategoryDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    categoryPut
    (id
    : string
        , body
    : CategoryCreateUpdateDto | undefined 
        ,): Promise<CategoryDto> {
        let url_ = this.baseUrl + "/api/app/category/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

                return request({
                            data: content_,
                                    method: "PUT",
                    url: url_,
                    header: {
                                        "Content-Type": "application/json",
                                        "Accept": "text/plain"
                            },
                }).catch((_error: any) => {
            throw _error;
        }).then((_response) => {
            return this.processCategoryPut(_response);
        });
    }

    protected processCategoryPut(response): Promise<CategoryDto> {
        const status = response.status || response.statusCode;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText.result || _responseText;
            result200 = CategoryDto.fromJS(resultData200, _mappings);
            return result200;
        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText.result || _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403, _mappings);
            return throwException("Forbidden", status, _responseText, _headers, result403);
        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText.result || _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401, _mappings);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText.result || _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400, _mappings);
            return throwException("Bad Request", status, _responseText, _headers, result400);
        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText.result || _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404, _mappings);
            return throwException("Not Found", status, _responseText, _headers, result404);
        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText.result || _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501, _mappings);
            return throwException("Server Error", status, _responseText, _headers, result501);
        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText.result || _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500, _mappings);
            return throwException("Server Error", status, _responseText, _headers, result500);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<CategoryDto>(<any>null);
    }

    /**
     * @return Success
     */
    categoryDelete
    (id
    : string 
        ,): Promise<void> {
        let url_ = this.baseUrl + "/api/app/category/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

                return request({
                                    method: "DELETE",
                    url: url_,
                    header: {
                                            },
                }).catch((_error: any) => {
            throw _error;
        }).then((_response) => {
            return this.processCategoryDelete(_response);
        });
    }

    protected processCategoryDelete(response): Promise<void> {
        const status = response.status || response.statusCode;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(<any>null);
        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText.result || _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403, _mappings);
            return throwException("Forbidden", status, _responseText, _headers, result403);
        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText.result || _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401, _mappings);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText.result || _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400, _mappings);
            return throwException("Bad Request", status, _responseText, _headers, result400);
        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText.result || _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404, _mappings);
            return throwException("Not Found", status, _responseText, _headers, result404);
        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText.result || _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501, _mappings);
            return throwException("Server Error", status, _responseText, _headers, result501);
        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText.result || _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500, _mappings);
            return throwException("Server Error", status, _responseText, _headers, result500);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(<any>null);
    }

    /**
     * @return Success
     */
    categoryGet
    (id
    : string 
        ,): Promise<CategoryDto> {
        let url_ = this.baseUrl + "/api/app/category/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

                return request({
                                    method: "GET",
                    url: url_,
                    header: {
                                                "Accept": "text/plain"
                            },
                }).catch((_error: any) => {
            throw _error;
        }).then((_response) => {
            return this.processCategoryGet(_response);
        });
    }

    protected processCategoryGet(response): Promise<CategoryDto> {
        const status = response.status || response.statusCode;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText.result || _responseText;
            result200 = CategoryDto.fromJS(resultData200, _mappings);
            return result200;
        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText.result || _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403, _mappings);
            return throwException("Forbidden", status, _responseText, _headers, result403);
        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText.result || _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401, _mappings);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText.result || _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400, _mappings);
            return throwException("Bad Request", status, _responseText, _headers, result400);
        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText.result || _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404, _mappings);
            return throwException("Not Found", status, _responseText, _headers, result404);
        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText.result || _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501, _mappings);
            return throwException("Server Error", status, _responseText, _headers, result501);
        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText.result || _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500, _mappings);
            return throwException("Server Error", status, _responseText, _headers, result500);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<CategoryDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    currencyPost
    (body
    : CurrencyDto | undefined 
        ,): Promise<CurrencyDto> {
        let url_ = this.baseUrl + "/api/app/currency";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

                return request({
                            data: content_,
                                    method: "POST",
                    url: url_,
                    header: {
                                        "Content-Type": "application/json",
                                        "Accept": "text/plain"
                            },
                }).catch((_error: any) => {
            throw _error;
        }).then((_response) => {
            return this.processCurrencyPost(_response);
        });
    }

    protected processCurrencyPost(response): Promise<CurrencyDto> {
        const status = response.status || response.statusCode;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText.result || _responseText;
            result200 = CurrencyDto.fromJS(resultData200, _mappings);
            return result200;
        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText.result || _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403, _mappings);
            return throwException("Forbidden", status, _responseText, _headers, result403);
        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText.result || _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401, _mappings);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText.result || _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400, _mappings);
            return throwException("Bad Request", status, _responseText, _headers, result400);
        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText.result || _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404, _mappings);
            return throwException("Not Found", status, _responseText, _headers, result404);
        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText.result || _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501, _mappings);
            return throwException("Server Error", status, _responseText, _headers, result501);
        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText.result || _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500, _mappings);
            return throwException("Server Error", status, _responseText, _headers, result500);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<CurrencyDto>(<any>null);
    }

    /**
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @param sorting (optional) 
     * @return Success
     */
    currencyGet
    (skipCount
    : number | undefined
        , maxResultCount
    : number | undefined
        , sorting
    : string | undefined 
        ,): Promise<PagedResultDto_1OfOfCurrencyDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null> {
        let url_ = this.baseUrl + "/api/app/currency?";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        url_ = url_.replace(/[?&]$/, "");

                return request({
                                    method: "GET",
                    url: url_,
                    header: {
                                                "Accept": "text/plain"
                            },
                }).catch((_error: any) => {
            throw _error;
        }).then((_response) => {
            return this.processCurrencyGet(_response);
        });
    }

    protected processCurrencyGet(response): Promise<PagedResultDto_1OfOfCurrencyDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null> {
        const status = response.status || response.statusCode;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText.result || _responseText;
            result200 = PagedResultDto_1OfOfCurrencyDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null.fromJS(resultData200, _mappings);
            return result200;
        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText.result || _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403, _mappings);
            return throwException("Forbidden", status, _responseText, _headers, result403);
        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText.result || _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401, _mappings);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText.result || _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400, _mappings);
            return throwException("Bad Request", status, _responseText, _headers, result400);
        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText.result || _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404, _mappings);
            return throwException("Not Found", status, _responseText, _headers, result404);
        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText.result || _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501, _mappings);
            return throwException("Server Error", status, _responseText, _headers, result501);
        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText.result || _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500, _mappings);
            return throwException("Server Error", status, _responseText, _headers, result500);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<PagedResultDto_1OfOfCurrencyDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    currencyPut
    (id
    : string
        , body
    : CurrencyDto | undefined 
        ,): Promise<CurrencyDto> {
        let url_ = this.baseUrl + "/api/app/currency/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

                return request({
                            data: content_,
                                    method: "PUT",
                    url: url_,
                    header: {
                                        "Content-Type": "application/json",
                                        "Accept": "text/plain"
                            },
                }).catch((_error: any) => {
            throw _error;
        }).then((_response) => {
            return this.processCurrencyPut(_response);
        });
    }

    protected processCurrencyPut(response): Promise<CurrencyDto> {
        const status = response.status || response.statusCode;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText.result || _responseText;
            result200 = CurrencyDto.fromJS(resultData200, _mappings);
            return result200;
        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText.result || _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403, _mappings);
            return throwException("Forbidden", status, _responseText, _headers, result403);
        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText.result || _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401, _mappings);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText.result || _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400, _mappings);
            return throwException("Bad Request", status, _responseText, _headers, result400);
        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText.result || _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404, _mappings);
            return throwException("Not Found", status, _responseText, _headers, result404);
        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText.result || _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501, _mappings);
            return throwException("Server Error", status, _responseText, _headers, result501);
        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText.result || _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500, _mappings);
            return throwException("Server Error", status, _responseText, _headers, result500);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<CurrencyDto>(<any>null);
    }

    /**
     * @return Success
     */
    currencyDelete
    (id
    : string 
        ,): Promise<void> {
        let url_ = this.baseUrl + "/api/app/currency/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

                return request({
                                    method: "DELETE",
                    url: url_,
                    header: {
                                            },
                }).catch((_error: any) => {
            throw _error;
        }).then((_response) => {
            return this.processCurrencyDelete(_response);
        });
    }

    protected processCurrencyDelete(response): Promise<void> {
        const status = response.status || response.statusCode;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(<any>null);
        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText.result || _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403, _mappings);
            return throwException("Forbidden", status, _responseText, _headers, result403);
        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText.result || _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401, _mappings);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText.result || _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400, _mappings);
            return throwException("Bad Request", status, _responseText, _headers, result400);
        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText.result || _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404, _mappings);
            return throwException("Not Found", status, _responseText, _headers, result404);
        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText.result || _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501, _mappings);
            return throwException("Server Error", status, _responseText, _headers, result501);
        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText.result || _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500, _mappings);
            return throwException("Server Error", status, _responseText, _headers, result500);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(<any>null);
    }

    /**
     * @return Success
     */
    currencyGet
    (id
    : string 
        ,): Promise<CurrencyDto> {
        let url_ = this.baseUrl + "/api/app/currency/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

                return request({
                                    method: "GET",
                    url: url_,
                    header: {
                                                "Accept": "text/plain"
                            },
                }).catch((_error: any) => {
            throw _error;
        }).then((_response) => {
            return this.processCurrencyGet(_response);
        });
    }

    protected processCurrencyGet(response): Promise<CurrencyDto> {
        const status = response.status || response.statusCode;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText.result || _responseText;
            result200 = CurrencyDto.fromJS(resultData200, _mappings);
            return result200;
        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText.result || _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403, _mappings);
            return throwException("Forbidden", status, _responseText, _headers, result403);
        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText.result || _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401, _mappings);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText.result || _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400, _mappings);
            return throwException("Bad Request", status, _responseText, _headers, result400);
        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText.result || _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404, _mappings);
            return throwException("Not Found", status, _responseText, _headers, result404);
        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText.result || _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501, _mappings);
            return throwException("Server Error", status, _responseText, _headers, result501);
        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText.result || _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500, _mappings);
            return throwException("Server Error", status, _responseText, _headers, result500);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<CurrencyDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    tagPost
    (body
    : TagCreateUpdateDto | undefined 
        ,): Promise<TagDto> {
        let url_ = this.baseUrl + "/api/app/tag";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

                return request({
                            data: content_,
                                    method: "POST",
                    url: url_,
                    header: {
                                        "Content-Type": "application/json",
                                        "Accept": "text/plain"
                            },
                }).catch((_error: any) => {
            throw _error;
        }).then((_response) => {
            return this.processTagPost(_response);
        });
    }

    protected processTagPost(response): Promise<TagDto> {
        const status = response.status || response.statusCode;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText.result || _responseText;
            result200 = TagDto.fromJS(resultData200, _mappings);
            return result200;
        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText.result || _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403, _mappings);
            return throwException("Forbidden", status, _responseText, _headers, result403);
        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText.result || _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401, _mappings);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText.result || _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400, _mappings);
            return throwException("Bad Request", status, _responseText, _headers, result400);
        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText.result || _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404, _mappings);
            return throwException("Not Found", status, _responseText, _headers, result404);
        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText.result || _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501, _mappings);
            return throwException("Server Error", status, _responseText, _headers, result501);
        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText.result || _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500, _mappings);
            return throwException("Server Error", status, _responseText, _headers, result500);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<TagDto>(<any>null);
    }

    /**
     * @param ids (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    tagGet
    (ids
    : string[] | undefined
        , skipCount
    : number | undefined
        , maxResultCount
    : number | undefined 
        ,): Promise<PagedResultDto_1OfOfTagDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null> {
        let url_ = this.baseUrl + "/api/app/tag?";
        if (ids === null)
            throw new Error("The parameter 'ids' cannot be null.");
        else if (ids !== undefined)
            ids && ids.forEach(item => { url_ += "Ids=" + encodeURIComponent("" + item) + "&"; });
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

                return request({
                                    method: "GET",
                    url: url_,
                    header: {
                                                "Accept": "text/plain"
                            },
                }).catch((_error: any) => {
            throw _error;
        }).then((_response) => {
            return this.processTagGet(_response);
        });
    }

    protected processTagGet(response): Promise<PagedResultDto_1OfOfTagDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null> {
        const status = response.status || response.statusCode;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText.result || _responseText;
            result200 = PagedResultDto_1OfOfTagDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null.fromJS(resultData200, _mappings);
            return result200;
        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText.result || _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403, _mappings);
            return throwException("Forbidden", status, _responseText, _headers, result403);
        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText.result || _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401, _mappings);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText.result || _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400, _mappings);
            return throwException("Bad Request", status, _responseText, _headers, result400);
        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText.result || _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404, _mappings);
            return throwException("Not Found", status, _responseText, _headers, result404);
        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText.result || _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501, _mappings);
            return throwException("Server Error", status, _responseText, _headers, result501);
        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText.result || _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500, _mappings);
            return throwException("Server Error", status, _responseText, _headers, result500);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<PagedResultDto_1OfOfTagDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    tagPut
    (id
    : string
        , body
    : TagCreateUpdateDto | undefined 
        ,): Promise<TagDto> {
        let url_ = this.baseUrl + "/api/app/tag/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

                return request({
                            data: content_,
                                    method: "PUT",
                    url: url_,
                    header: {
                                        "Content-Type": "application/json",
                                        "Accept": "text/plain"
                            },
                }).catch((_error: any) => {
            throw _error;
        }).then((_response) => {
            return this.processTagPut(_response);
        });
    }

    protected processTagPut(response): Promise<TagDto> {
        const status = response.status || response.statusCode;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText.result || _responseText;
            result200 = TagDto.fromJS(resultData200, _mappings);
            return result200;
        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText.result || _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403, _mappings);
            return throwException("Forbidden", status, _responseText, _headers, result403);
        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText.result || _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401, _mappings);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText.result || _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400, _mappings);
            return throwException("Bad Request", status, _responseText, _headers, result400);
        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText.result || _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404, _mappings);
            return throwException("Not Found", status, _responseText, _headers, result404);
        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText.result || _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501, _mappings);
            return throwException("Server Error", status, _responseText, _headers, result501);
        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText.result || _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500, _mappings);
            return throwException("Server Error", status, _responseText, _headers, result500);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<TagDto>(<any>null);
    }

    /**
     * @return Success
     */
    tagDelete
    (id
    : string 
        ,): Promise<void> {
        let url_ = this.baseUrl + "/api/app/tag/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

                return request({
                                    method: "DELETE",
                    url: url_,
                    header: {
                                            },
                }).catch((_error: any) => {
            throw _error;
        }).then((_response) => {
            return this.processTagDelete(_response);
        });
    }

    protected processTagDelete(response): Promise<void> {
        const status = response.status || response.statusCode;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(<any>null);
        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText.result || _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403, _mappings);
            return throwException("Forbidden", status, _responseText, _headers, result403);
        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText.result || _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401, _mappings);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText.result || _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400, _mappings);
            return throwException("Bad Request", status, _responseText, _headers, result400);
        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText.result || _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404, _mappings);
            return throwException("Not Found", status, _responseText, _headers, result404);
        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText.result || _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501, _mappings);
            return throwException("Server Error", status, _responseText, _headers, result501);
        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText.result || _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500, _mappings);
            return throwException("Server Error", status, _responseText, _headers, result500);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(<any>null);
    }

    /**
     * @return Success
     */
    tagGet
    (id
    : string 
        ,): Promise<TagDto> {
        let url_ = this.baseUrl + "/api/app/tag/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

                return request({
                                    method: "GET",
                    url: url_,
                    header: {
                                                "Accept": "text/plain"
                            },
                }).catch((_error: any) => {
            throw _error;
        }).then((_response) => {
            return this.processTagGet(_response);
        });
    }

    protected processTagGet(response): Promise<TagDto> {
        const status = response.status || response.statusCode;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText.result || _responseText;
            result200 = TagDto.fromJS(resultData200, _mappings);
            return result200;
        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText.result || _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403, _mappings);
            return throwException("Forbidden", status, _responseText, _headers, result403);
        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText.result || _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401, _mappings);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText.result || _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400, _mappings);
            return throwException("Bad Request", status, _responseText, _headers, result400);
        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText.result || _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404, _mappings);
            return throwException("Not Found", status, _responseText, _headers, result404);
        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText.result || _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501, _mappings);
            return throwException("Server Error", status, _responseText, _headers, result501);
        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText.result || _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500, _mappings);
            return throwException("Server Error", status, _responseText, _headers, result500);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<TagDto>(<any>null);
    }

    /**
     * @return Success
     */
    transactionGet
    (id
    : string 
        ,): Promise<TransactionDto> {
        let url_ = this.baseUrl + "/api/app/transaction/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

                return request({
                                    method: "GET",
                    url: url_,
                    header: {
                                                "Accept": "text/plain"
                            },
                }).catch((_error: any) => {
            throw _error;
        }).then((_response) => {
            return this.processTransactionGet(_response);
        });
    }

    protected processTransactionGet(response): Promise<TransactionDto> {
        const status = response.status || response.statusCode;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText.result || _responseText;
            result200 = TransactionDto.fromJS(resultData200, _mappings);
            return result200;
        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText.result || _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403, _mappings);
            return throwException("Forbidden", status, _responseText, _headers, result403);
        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText.result || _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401, _mappings);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText.result || _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400, _mappings);
            return throwException("Bad Request", status, _responseText, _headers, result400);
        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText.result || _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404, _mappings);
            return throwException("Not Found", status, _responseText, _headers, result404);
        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText.result || _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501, _mappings);
            return throwException("Server Error", status, _responseText, _headers, result501);
        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText.result || _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500, _mappings);
            return throwException("Server Error", status, _responseText, _headers, result500);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<TransactionDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    transactionPut
    (id
    : string
        , body
    : CreateUpdateTransactionDto | undefined 
        ,): Promise<TransactionDto> {
        let url_ = this.baseUrl + "/api/app/transaction/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

                return request({
                            data: content_,
                                    method: "PUT",
                    url: url_,
                    header: {
                                        "Content-Type": "application/json",
                                        "Accept": "text/plain"
                            },
                }).catch((_error: any) => {
            throw _error;
        }).then((_response) => {
            return this.processTransactionPut(_response);
        });
    }

    protected processTransactionPut(response): Promise<TransactionDto> {
        const status = response.status || response.statusCode;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText.result || _responseText;
            result200 = TransactionDto.fromJS(resultData200, _mappings);
            return result200;
        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText.result || _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403, _mappings);
            return throwException("Forbidden", status, _responseText, _headers, result403);
        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText.result || _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401, _mappings);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText.result || _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400, _mappings);
            return throwException("Bad Request", status, _responseText, _headers, result400);
        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText.result || _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404, _mappings);
            return throwException("Not Found", status, _responseText, _headers, result404);
        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText.result || _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501, _mappings);
            return throwException("Server Error", status, _responseText, _headers, result501);
        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText.result || _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500, _mappings);
            return throwException("Server Error", status, _responseText, _headers, result500);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<TransactionDto>(<any>null);
    }

    /**
     * @return Success
     */
    transactionDelete
    (id
    : string 
        ,): Promise<void> {
        let url_ = this.baseUrl + "/api/app/transaction/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

                return request({
                                    method: "DELETE",
                    url: url_,
                    header: {
                                            },
                }).catch((_error: any) => {
            throw _error;
        }).then((_response) => {
            return this.processTransactionDelete(_response);
        });
    }

    protected processTransactionDelete(response): Promise<void> {
        const status = response.status || response.statusCode;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(<any>null);
        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText.result || _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403, _mappings);
            return throwException("Forbidden", status, _responseText, _headers, result403);
        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText.result || _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401, _mappings);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText.result || _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400, _mappings);
            return throwException("Bad Request", status, _responseText, _headers, result400);
        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText.result || _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404, _mappings);
            return throwException("Not Found", status, _responseText, _headers, result404);
        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText.result || _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501, _mappings);
            return throwException("Server Error", status, _responseText, _headers, result501);
        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText.result || _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500, _mappings);
            return throwException("Server Error", status, _responseText, _headers, result500);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    transactionPost
    (body
    : CreateUpdateTransactionDto | undefined 
        ,): Promise<TransactionDto> {
        let url_ = this.baseUrl + "/api/app/transaction";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

                return request({
                            data: content_,
                                    method: "POST",
                    url: url_,
                    header: {
                                        "Content-Type": "application/json",
                                        "Accept": "text/plain"
                            },
                }).catch((_error: any) => {
            throw _error;
        }).then((_response) => {
            return this.processTransactionPost(_response);
        });
    }

    protected processTransactionPost(response): Promise<TransactionDto> {
        const status = response.status || response.statusCode;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText.result || _responseText;
            result200 = TransactionDto.fromJS(resultData200, _mappings);
            return result200;
        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText.result || _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403, _mappings);
            return throwException("Forbidden", status, _responseText, _headers, result403);
        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText.result || _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401, _mappings);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText.result || _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400, _mappings);
            return throwException("Bad Request", status, _responseText, _headers, result400);
        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText.result || _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404, _mappings);
            return throwException("Not Found", status, _responseText, _headers, result404);
        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText.result || _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501, _mappings);
            return throwException("Server Error", status, _responseText, _headers, result501);
        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText.result || _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500, _mappings);
            return throwException("Server Error", status, _responseText, _headers, result500);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<TransactionDto>(<any>null);
    }

    /**
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @param sorting (optional) 
     * @return Success
     */
    transactionGet
    (skipCount
    : number | undefined
        , maxResultCount
    : number | undefined
        , sorting
    : string | undefined 
        ,): Promise<PagedResultDto_1OfOfTransactionDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null> {
        let url_ = this.baseUrl + "/api/app/transaction?";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        url_ = url_.replace(/[?&]$/, "");

                return request({
                                    method: "GET",
                    url: url_,
                    header: {
                                                "Accept": "text/plain"
                            },
                }).catch((_error: any) => {
            throw _error;
        }).then((_response) => {
            return this.processTransactionGet(_response);
        });
    }

    protected processTransactionGet(response): Promise<PagedResultDto_1OfOfTransactionDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null> {
        const status = response.status || response.statusCode;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText.result || _responseText;
            result200 = PagedResultDto_1OfOfTransactionDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null.fromJS(resultData200, _mappings);
            return result200;
        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText.result || _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403, _mappings);
            return throwException("Forbidden", status, _responseText, _headers, result403);
        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText.result || _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401, _mappings);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText.result || _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400, _mappings);
            return throwException("Bad Request", status, _responseText, _headers, result400);
        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText.result || _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404, _mappings);
            return throwException("Not Found", status, _responseText, _headers, result404);
        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText.result || _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501, _mappings);
            return throwException("Server Error", status, _responseText, _headers, result501);
        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText.result || _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500, _mappings);
            return throwException("Server Error", status, _responseText, _headers, result500);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<PagedResultDto_1OfOfTransactionDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    transactionAttachmentPost
    (body
    : TransactionAttachmentCreateUpdateDto | undefined 
        ,): Promise<TransactionAttachmentDto> {
        let url_ = this.baseUrl + "/api/app/transaction-attachment";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

                return request({
                            data: content_,
                                    method: "POST",
                    url: url_,
                    header: {
                                        "Content-Type": "application/json",
                                        "Accept": "text/plain"
                            },
                }).catch((_error: any) => {
            throw _error;
        }).then((_response) => {
            return this.processTransactionAttachmentPost(_response);
        });
    }

    protected processTransactionAttachmentPost(response): Promise<TransactionAttachmentDto> {
        const status = response.status || response.statusCode;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText.result || _responseText;
            result200 = TransactionAttachmentDto.fromJS(resultData200, _mappings);
            return result200;
        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText.result || _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403, _mappings);
            return throwException("Forbidden", status, _responseText, _headers, result403);
        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText.result || _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401, _mappings);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText.result || _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400, _mappings);
            return throwException("Bad Request", status, _responseText, _headers, result400);
        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText.result || _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404, _mappings);
            return throwException("Not Found", status, _responseText, _headers, result404);
        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText.result || _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501, _mappings);
            return throwException("Server Error", status, _responseText, _headers, result501);
        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText.result || _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500, _mappings);
            return throwException("Server Error", status, _responseText, _headers, result500);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<TransactionAttachmentDto>(<any>null);
    }

    /**
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @param sorting (optional) 
     * @return Success
     */
    transactionAttachmentGet
    (skipCount
    : number | undefined
        , maxResultCount
    : number | undefined
        , sorting
    : string | undefined 
        ,): Promise<PagedResultDto_1OfOfTransactionAttachmentDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null> {
        let url_ = this.baseUrl + "/api/app/transaction-attachment?";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        url_ = url_.replace(/[?&]$/, "");

                return request({
                                    method: "GET",
                    url: url_,
                    header: {
                                                "Accept": "text/plain"
                            },
                }).catch((_error: any) => {
            throw _error;
        }).then((_response) => {
            return this.processTransactionAttachmentGet(_response);
        });
    }

    protected processTransactionAttachmentGet(response): Promise<PagedResultDto_1OfOfTransactionAttachmentDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null> {
        const status = response.status || response.statusCode;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText.result || _responseText;
            result200 = PagedResultDto_1OfOfTransactionAttachmentDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null.fromJS(resultData200, _mappings);
            return result200;
        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText.result || _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403, _mappings);
            return throwException("Forbidden", status, _responseText, _headers, result403);
        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText.result || _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401, _mappings);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText.result || _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400, _mappings);
            return throwException("Bad Request", status, _responseText, _headers, result400);
        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText.result || _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404, _mappings);
            return throwException("Not Found", status, _responseText, _headers, result404);
        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText.result || _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501, _mappings);
            return throwException("Server Error", status, _responseText, _headers, result501);
        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText.result || _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500, _mappings);
            return throwException("Server Error", status, _responseText, _headers, result500);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<PagedResultDto_1OfOfTransactionAttachmentDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    transactionAttachmentPut
    (id
    : string
        , body
    : TransactionAttachmentCreateUpdateDto | undefined 
        ,): Promise<TransactionAttachmentDto> {
        let url_ = this.baseUrl + "/api/app/transaction-attachment/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

                return request({
                            data: content_,
                                    method: "PUT",
                    url: url_,
                    header: {
                                        "Content-Type": "application/json",
                                        "Accept": "text/plain"
                            },
                }).catch((_error: any) => {
            throw _error;
        }).then((_response) => {
            return this.processTransactionAttachmentPut(_response);
        });
    }

    protected processTransactionAttachmentPut(response): Promise<TransactionAttachmentDto> {
        const status = response.status || response.statusCode;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText.result || _responseText;
            result200 = TransactionAttachmentDto.fromJS(resultData200, _mappings);
            return result200;
        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText.result || _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403, _mappings);
            return throwException("Forbidden", status, _responseText, _headers, result403);
        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText.result || _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401, _mappings);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText.result || _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400, _mappings);
            return throwException("Bad Request", status, _responseText, _headers, result400);
        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText.result || _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404, _mappings);
            return throwException("Not Found", status, _responseText, _headers, result404);
        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText.result || _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501, _mappings);
            return throwException("Server Error", status, _responseText, _headers, result501);
        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText.result || _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500, _mappings);
            return throwException("Server Error", status, _responseText, _headers, result500);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<TransactionAttachmentDto>(<any>null);
    }

    /**
     * @return Success
     */
    transactionAttachmentDelete
    (id
    : string 
        ,): Promise<void> {
        let url_ = this.baseUrl + "/api/app/transaction-attachment/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

                return request({
                                    method: "DELETE",
                    url: url_,
                    header: {
                                            },
                }).catch((_error: any) => {
            throw _error;
        }).then((_response) => {
            return this.processTransactionAttachmentDelete(_response);
        });
    }

    protected processTransactionAttachmentDelete(response): Promise<void> {
        const status = response.status || response.statusCode;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(<any>null);
        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText.result || _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403, _mappings);
            return throwException("Forbidden", status, _responseText, _headers, result403);
        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText.result || _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401, _mappings);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText.result || _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400, _mappings);
            return throwException("Bad Request", status, _responseText, _headers, result400);
        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText.result || _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404, _mappings);
            return throwException("Not Found", status, _responseText, _headers, result404);
        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText.result || _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501, _mappings);
            return throwException("Server Error", status, _responseText, _headers, result501);
        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText.result || _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500, _mappings);
            return throwException("Server Error", status, _responseText, _headers, result500);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(<any>null);
    }

    /**
     * @return Success
     */
    transactionAttachmentGet
    (id
    : string 
        ,): Promise<TransactionAttachmentDto> {
        let url_ = this.baseUrl + "/api/app/transaction-attachment/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

                return request({
                                    method: "GET",
                    url: url_,
                    header: {
                                                "Accept": "text/plain"
                            },
                }).catch((_error: any) => {
            throw _error;
        }).then((_response) => {
            return this.processTransactionAttachmentGet(_response);
        });
    }

    protected processTransactionAttachmentGet(response): Promise<TransactionAttachmentDto> {
        const status = response.status || response.statusCode;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText.result || _responseText;
            result200 = TransactionAttachmentDto.fromJS(resultData200, _mappings);
            return result200;
        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText.result || _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403, _mappings);
            return throwException("Forbidden", status, _responseText, _headers, result403);
        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText.result || _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401, _mappings);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText.result || _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400, _mappings);
            return throwException("Bad Request", status, _responseText, _headers, result400);
        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText.result || _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404, _mappings);
            return throwException("Not Found", status, _responseText, _headers, result404);
        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText.result || _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501, _mappings);
            return throwException("Server Error", status, _responseText, _headers, result501);
        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText.result || _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500, _mappings);
            return throwException("Server Error", status, _responseText, _headers, result500);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<TransactionAttachmentDto>(<any>null);
    }
}

export class SettingManagementServiceProxy extends AbpServiceBase {
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string) {
        super();
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @return Success
     */
    emailingGet
    ( ): Promise<EmailSettingsDto> {
        let url_ = this.baseUrl + "/api/setting-management/emailing";
        url_ = url_.replace(/[?&]$/, "");

                return request({
                                    method: "GET",
                    url: url_,
                    header: {
                                                "Accept": "text/plain"
                            },
                }).catch((_error: any) => {
            throw _error;
        }).then((_response) => {
            return this.processEmailingGet(_response);
        });
    }

    protected processEmailingGet(response): Promise<EmailSettingsDto> {
        const status = response.status || response.statusCode;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText.result || _responseText;
            result200 = EmailSettingsDto.fromJS(resultData200, _mappings);
            return result200;
        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText.result || _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403, _mappings);
            return throwException("Forbidden", status, _responseText, _headers, result403);
        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText.result || _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401, _mappings);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText.result || _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400, _mappings);
            return throwException("Bad Request", status, _responseText, _headers, result400);
        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText.result || _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404, _mappings);
            return throwException("Not Found", status, _responseText, _headers, result404);
        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText.result || _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501, _mappings);
            return throwException("Server Error", status, _responseText, _headers, result501);
        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText.result || _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500, _mappings);
            return throwException("Server Error", status, _responseText, _headers, result500);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<EmailSettingsDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    emailingPost
    (body
    : UpdateEmailSettingsDto | undefined 
        ,): Promise<void> {
        let url_ = this.baseUrl + "/api/setting-management/emailing";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

                return request({
                            data: content_,
                                    method: "POST",
                    url: url_,
                    header: {
                                        "Content-Type": "application/json",
                                    },
                }).catch((_error: any) => {
            throw _error;
        }).then((_response) => {
            return this.processEmailingPost(_response);
        });
    }

    protected processEmailingPost(response): Promise<void> {
        const status = response.status || response.statusCode;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(<any>null);
        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText.result || _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403, _mappings);
            return throwException("Forbidden", status, _responseText, _headers, result403);
        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText.result || _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401, _mappings);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText.result || _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400, _mappings);
            return throwException("Bad Request", status, _responseText, _headers, result400);
        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText.result || _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404, _mappings);
            return throwException("Not Found", status, _responseText, _headers, result404);
        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText.result || _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501, _mappings);
            return throwException("Server Error", status, _responseText, _headers, result501);
        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText.result || _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500, _mappings);
            return throwException("Server Error", status, _responseText, _headers, result500);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(<any>null);
    }
}

export class FeatureManagementServiceProxy extends AbpServiceBase {
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string) {
        super();
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param providerName (optional) 
     * @param providerKey (optional) 
     * @return Success
     */
    featuresGet
    (providerName
    : string | undefined
        , providerKey
    : string | undefined 
        ,): Promise<GetFeatureListResultDto> {
        let url_ = this.baseUrl + "/api/feature-management/features?";
        if (providerName === null)
            throw new Error("The parameter 'providerName' cannot be null.");
        else if (providerName !== undefined)
            url_ += "providerName=" + encodeURIComponent("" + providerName) + "&";
        if (providerKey === null)
            throw new Error("The parameter 'providerKey' cannot be null.");
        else if (providerKey !== undefined)
            url_ += "providerKey=" + encodeURIComponent("" + providerKey) + "&";
        url_ = url_.replace(/[?&]$/, "");

                return request({
                                    method: "GET",
                    url: url_,
                    header: {
                                                "Accept": "text/plain"
                            },
                }).catch((_error: any) => {
            throw _error;
        }).then((_response) => {
            return this.processFeaturesGet(_response);
        });
    }

    protected processFeaturesGet(response): Promise<GetFeatureListResultDto> {
        const status = response.status || response.statusCode;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText.result || _responseText;
            result200 = GetFeatureListResultDto.fromJS(resultData200, _mappings);
            return result200;
        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText.result || _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403, _mappings);
            return throwException("Forbidden", status, _responseText, _headers, result403);
        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText.result || _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401, _mappings);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText.result || _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400, _mappings);
            return throwException("Bad Request", status, _responseText, _headers, result400);
        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText.result || _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404, _mappings);
            return throwException("Not Found", status, _responseText, _headers, result404);
        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText.result || _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501, _mappings);
            return throwException("Server Error", status, _responseText, _headers, result501);
        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText.result || _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500, _mappings);
            return throwException("Server Error", status, _responseText, _headers, result500);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<GetFeatureListResultDto>(<any>null);
    }

    /**
     * @param providerName (optional) 
     * @param providerKey (optional) 
     * @param body (optional) 
     * @return Success
     */
    featuresPut
    (providerName
    : string | undefined
        , providerKey
    : string | undefined
        , body
    : UpdateFeaturesDto | undefined 
        ,): Promise<void> {
        let url_ = this.baseUrl + "/api/feature-management/features?";
        if (providerName === null)
            throw new Error("The parameter 'providerName' cannot be null.");
        else if (providerName !== undefined)
            url_ += "providerName=" + encodeURIComponent("" + providerName) + "&";
        if (providerKey === null)
            throw new Error("The parameter 'providerKey' cannot be null.");
        else if (providerKey !== undefined)
            url_ += "providerKey=" + encodeURIComponent("" + providerKey) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

                return request({
                            data: content_,
                                    method: "PUT",
                    url: url_,
                    header: {
                                        "Content-Type": "application/json",
                                    },
                }).catch((_error: any) => {
            throw _error;
        }).then((_response) => {
            return this.processFeaturesPut(_response);
        });
    }

    protected processFeaturesPut(response): Promise<void> {
        const status = response.status || response.statusCode;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(<any>null);
        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText.result || _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403, _mappings);
            return throwException("Forbidden", status, _responseText, _headers, result403);
        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText.result || _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401, _mappings);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText.result || _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400, _mappings);
            return throwException("Bad Request", status, _responseText, _headers, result400);
        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText.result || _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404, _mappings);
            return throwException("Not Found", status, _responseText, _headers, result404);
        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText.result || _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501, _mappings);
            return throwException("Server Error", status, _responseText, _headers, result501);
        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText.result || _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500, _mappings);
            return throwException("Server Error", status, _responseText, _headers, result500);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(<any>null);
    }
}

export class PermissionManagementServiceProxy extends AbpServiceBase {
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string) {
        super();
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param providerName (optional) 
     * @param providerKey (optional) 
     * @return Success
     */
    permissionsGet
    (providerName
    : string | undefined
        , providerKey
    : string | undefined 
        ,): Promise<GetPermissionListResultDto> {
        let url_ = this.baseUrl + "/api/permission-management/permissions?";
        if (providerName === null)
            throw new Error("The parameter 'providerName' cannot be null.");
        else if (providerName !== undefined)
            url_ += "providerName=" + encodeURIComponent("" + providerName) + "&";
        if (providerKey === null)
            throw new Error("The parameter 'providerKey' cannot be null.");
        else if (providerKey !== undefined)
            url_ += "providerKey=" + encodeURIComponent("" + providerKey) + "&";
        url_ = url_.replace(/[?&]$/, "");

                return request({
                                    method: "GET",
                    url: url_,
                    header: {
                                                "Accept": "text/plain"
                            },
                }).catch((_error: any) => {
            throw _error;
        }).then((_response) => {
            return this.processPermissionsGet(_response);
        });
    }

    protected processPermissionsGet(response): Promise<GetPermissionListResultDto> {
        const status = response.status || response.statusCode;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText.result || _responseText;
            result200 = GetPermissionListResultDto.fromJS(resultData200, _mappings);
            return result200;
        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText.result || _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403, _mappings);
            return throwException("Forbidden", status, _responseText, _headers, result403);
        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText.result || _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401, _mappings);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText.result || _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400, _mappings);
            return throwException("Bad Request", status, _responseText, _headers, result400);
        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText.result || _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404, _mappings);
            return throwException("Not Found", status, _responseText, _headers, result404);
        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText.result || _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501, _mappings);
            return throwException("Server Error", status, _responseText, _headers, result501);
        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText.result || _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500, _mappings);
            return throwException("Server Error", status, _responseText, _headers, result500);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<GetPermissionListResultDto>(<any>null);
    }

    /**
     * @param providerName (optional) 
     * @param providerKey (optional) 
     * @param body (optional) 
     * @return Success
     */
    permissionsPut
    (providerName
    : string | undefined
        , providerKey
    : string | undefined
        , body
    : UpdatePermissionsDto | undefined 
        ,): Promise<void> {
        let url_ = this.baseUrl + "/api/permission-management/permissions?";
        if (providerName === null)
            throw new Error("The parameter 'providerName' cannot be null.");
        else if (providerName !== undefined)
            url_ += "providerName=" + encodeURIComponent("" + providerName) + "&";
        if (providerKey === null)
            throw new Error("The parameter 'providerKey' cannot be null.");
        else if (providerKey !== undefined)
            url_ += "providerKey=" + encodeURIComponent("" + providerKey) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

                return request({
                            data: content_,
                                    method: "PUT",
                    url: url_,
                    header: {
                                        "Content-Type": "application/json",
                                    },
                }).catch((_error: any) => {
            throw _error;
        }).then((_response) => {
            return this.processPermissionsPut(_response);
        });
    }

    protected processPermissionsPut(response): Promise<void> {
        const status = response.status || response.statusCode;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(<any>null);
        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText.result || _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403, _mappings);
            return throwException("Forbidden", status, _responseText, _headers, result403);
        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText.result || _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401, _mappings);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText.result || _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400, _mappings);
            return throwException("Bad Request", status, _responseText, _headers, result400);
        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText.result || _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404, _mappings);
            return throwException("Not Found", status, _responseText, _headers, result404);
        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText.result || _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501, _mappings);
            return throwException("Server Error", status, _responseText, _headers, result501);
        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText.result || _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500, _mappings);
            return throwException("Server Error", status, _responseText, _headers, result500);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(<any>null);
    }
}

export class IdentityServiceProxy extends AbpServiceBase {
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string) {
        super();
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @return Success
     */
    myProfileGet
    ( ): Promise<ProfileDto> {
        let url_ = this.baseUrl + "/api/identity/my-profile";
        url_ = url_.replace(/[?&]$/, "");

                return request({
                                    method: "GET",
                    url: url_,
                    header: {
                                                "Accept": "text/plain"
                            },
                }).catch((_error: any) => {
            throw _error;
        }).then((_response) => {
            return this.processMyProfileGet(_response);
        });
    }

    protected processMyProfileGet(response): Promise<ProfileDto> {
        const status = response.status || response.statusCode;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText.result || _responseText;
            result200 = ProfileDto.fromJS(resultData200, _mappings);
            return result200;
        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText.result || _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403, _mappings);
            return throwException("Forbidden", status, _responseText, _headers, result403);
        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText.result || _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401, _mappings);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText.result || _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400, _mappings);
            return throwException("Bad Request", status, _responseText, _headers, result400);
        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText.result || _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404, _mappings);
            return throwException("Not Found", status, _responseText, _headers, result404);
        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText.result || _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501, _mappings);
            return throwException("Server Error", status, _responseText, _headers, result501);
        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText.result || _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500, _mappings);
            return throwException("Server Error", status, _responseText, _headers, result500);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ProfileDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    myProfilePut
    (body
    : UpdateProfileDto | undefined 
        ,): Promise<ProfileDto> {
        let url_ = this.baseUrl + "/api/identity/my-profile";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

                return request({
                            data: content_,
                                    method: "PUT",
                    url: url_,
                    header: {
                                        "Content-Type": "application/json",
                                        "Accept": "text/plain"
                            },
                }).catch((_error: any) => {
            throw _error;
        }).then((_response) => {
            return this.processMyProfilePut(_response);
        });
    }

    protected processMyProfilePut(response): Promise<ProfileDto> {
        const status = response.status || response.statusCode;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText.result || _responseText;
            result200 = ProfileDto.fromJS(resultData200, _mappings);
            return result200;
        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText.result || _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403, _mappings);
            return throwException("Forbidden", status, _responseText, _headers, result403);
        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText.result || _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401, _mappings);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText.result || _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400, _mappings);
            return throwException("Bad Request", status, _responseText, _headers, result400);
        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText.result || _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404, _mappings);
            return throwException("Not Found", status, _responseText, _headers, result404);
        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText.result || _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501, _mappings);
            return throwException("Server Error", status, _responseText, _headers, result501);
        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText.result || _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500, _mappings);
            return throwException("Server Error", status, _responseText, _headers, result500);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ProfileDto>(<any>null);
    }

    /**
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    rolesGet
    (filter
    : string | undefined
        , sorting
    : string | undefined
        , skipCount
    : number | undefined
        , maxResultCount
    : number | undefined 
        ,): Promise<PagedResultDto_1OfOfIdentityRoleDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null> {
        let url_ = this.baseUrl + "/api/identity/roles?";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

                return request({
                                    method: "GET",
                    url: url_,
                    header: {
                                                "Accept": "text/plain"
                            },
                }).catch((_error: any) => {
            throw _error;
        }).then((_response) => {
            return this.processRolesGet(_response);
        });
    }

    protected processRolesGet(response): Promise<PagedResultDto_1OfOfIdentityRoleDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null> {
        const status = response.status || response.statusCode;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText.result || _responseText;
            result200 = PagedResultDto_1OfOfIdentityRoleDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null.fromJS(resultData200, _mappings);
            return result200;
        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText.result || _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403, _mappings);
            return throwException("Forbidden", status, _responseText, _headers, result403);
        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText.result || _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401, _mappings);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText.result || _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400, _mappings);
            return throwException("Bad Request", status, _responseText, _headers, result400);
        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText.result || _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404, _mappings);
            return throwException("Not Found", status, _responseText, _headers, result404);
        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText.result || _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501, _mappings);
            return throwException("Server Error", status, _responseText, _headers, result501);
        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText.result || _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500, _mappings);
            return throwException("Server Error", status, _responseText, _headers, result500);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<PagedResultDto_1OfOfIdentityRoleDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    rolesPost
    (body
    : IdentityRoleCreateDto | undefined 
        ,): Promise<IdentityRoleDto> {
        let url_ = this.baseUrl + "/api/identity/roles";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

                return request({
                            data: content_,
                                    method: "POST",
                    url: url_,
                    header: {
                                        "Content-Type": "application/json",
                                        "Accept": "text/plain"
                            },
                }).catch((_error: any) => {
            throw _error;
        }).then((_response) => {
            return this.processRolesPost(_response);
        });
    }

    protected processRolesPost(response): Promise<IdentityRoleDto> {
        const status = response.status || response.statusCode;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText.result || _responseText;
            result200 = IdentityRoleDto.fromJS(resultData200, _mappings);
            return result200;
        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText.result || _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403, _mappings);
            return throwException("Forbidden", status, _responseText, _headers, result403);
        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText.result || _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401, _mappings);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText.result || _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400, _mappings);
            return throwException("Bad Request", status, _responseText, _headers, result400);
        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText.result || _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404, _mappings);
            return throwException("Not Found", status, _responseText, _headers, result404);
        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText.result || _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501, _mappings);
            return throwException("Server Error", status, _responseText, _headers, result501);
        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText.result || _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500, _mappings);
            return throwException("Server Error", status, _responseText, _headers, result500);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<IdentityRoleDto>(<any>null);
    }

    /**
     * @return Success
     */
    rolesGet
    (id
    : string 
        ,): Promise<IdentityRoleDto> {
        let url_ = this.baseUrl + "/api/identity/roles/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

                return request({
                                    method: "GET",
                    url: url_,
                    header: {
                                                "Accept": "text/plain"
                            },
                }).catch((_error: any) => {
            throw _error;
        }).then((_response) => {
            return this.processRolesGet(_response);
        });
    }

    protected processRolesGet(response): Promise<IdentityRoleDto> {
        const status = response.status || response.statusCode;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText.result || _responseText;
            result200 = IdentityRoleDto.fromJS(resultData200, _mappings);
            return result200;
        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText.result || _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403, _mappings);
            return throwException("Forbidden", status, _responseText, _headers, result403);
        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText.result || _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401, _mappings);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText.result || _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400, _mappings);
            return throwException("Bad Request", status, _responseText, _headers, result400);
        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText.result || _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404, _mappings);
            return throwException("Not Found", status, _responseText, _headers, result404);
        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText.result || _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501, _mappings);
            return throwException("Server Error", status, _responseText, _headers, result501);
        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText.result || _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500, _mappings);
            return throwException("Server Error", status, _responseText, _headers, result500);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<IdentityRoleDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    rolesPut
    (id
    : string
        , body
    : IdentityRoleUpdateDto | undefined 
        ,): Promise<IdentityRoleDto> {
        let url_ = this.baseUrl + "/api/identity/roles/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

                return request({
                            data: content_,
                                    method: "PUT",
                    url: url_,
                    header: {
                                        "Content-Type": "application/json",
                                        "Accept": "text/plain"
                            },
                }).catch((_error: any) => {
            throw _error;
        }).then((_response) => {
            return this.processRolesPut(_response);
        });
    }

    protected processRolesPut(response): Promise<IdentityRoleDto> {
        const status = response.status || response.statusCode;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText.result || _responseText;
            result200 = IdentityRoleDto.fromJS(resultData200, _mappings);
            return result200;
        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText.result || _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403, _mappings);
            return throwException("Forbidden", status, _responseText, _headers, result403);
        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText.result || _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401, _mappings);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText.result || _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400, _mappings);
            return throwException("Bad Request", status, _responseText, _headers, result400);
        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText.result || _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404, _mappings);
            return throwException("Not Found", status, _responseText, _headers, result404);
        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText.result || _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501, _mappings);
            return throwException("Server Error", status, _responseText, _headers, result501);
        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText.result || _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500, _mappings);
            return throwException("Server Error", status, _responseText, _headers, result500);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<IdentityRoleDto>(<any>null);
    }

    /**
     * @return Success
     */
    rolesDelete
    (id
    : string 
        ,): Promise<void> {
        let url_ = this.baseUrl + "/api/identity/roles/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

                return request({
                                    method: "DELETE",
                    url: url_,
                    header: {
                                            },
                }).catch((_error: any) => {
            throw _error;
        }).then((_response) => {
            return this.processRolesDelete(_response);
        });
    }

    protected processRolesDelete(response): Promise<void> {
        const status = response.status || response.statusCode;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(<any>null);
        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText.result || _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403, _mappings);
            return throwException("Forbidden", status, _responseText, _headers, result403);
        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText.result || _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401, _mappings);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText.result || _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400, _mappings);
            return throwException("Bad Request", status, _responseText, _headers, result400);
        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText.result || _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404, _mappings);
            return throwException("Not Found", status, _responseText, _headers, result404);
        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText.result || _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501, _mappings);
            return throwException("Server Error", status, _responseText, _headers, result501);
        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText.result || _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500, _mappings);
            return throwException("Server Error", status, _responseText, _headers, result500);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(<any>null);
    }

    /**
     * @return Success
     */
    usersGet
    (id
    : string 
        ,): Promise<IdentityUserDto> {
        let url_ = this.baseUrl + "/api/identity/users/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

                return request({
                                    method: "GET",
                    url: url_,
                    header: {
                                                "Accept": "text/plain"
                            },
                }).catch((_error: any) => {
            throw _error;
        }).then((_response) => {
            return this.processUsersGet(_response);
        });
    }

    protected processUsersGet(response): Promise<IdentityUserDto> {
        const status = response.status || response.statusCode;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText.result || _responseText;
            result200 = IdentityUserDto.fromJS(resultData200, _mappings);
            return result200;
        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText.result || _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403, _mappings);
            return throwException("Forbidden", status, _responseText, _headers, result403);
        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText.result || _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401, _mappings);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText.result || _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400, _mappings);
            return throwException("Bad Request", status, _responseText, _headers, result400);
        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText.result || _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404, _mappings);
            return throwException("Not Found", status, _responseText, _headers, result404);
        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText.result || _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501, _mappings);
            return throwException("Server Error", status, _responseText, _headers, result501);
        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText.result || _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500, _mappings);
            return throwException("Server Error", status, _responseText, _headers, result500);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<IdentityUserDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    usersPut
    (id
    : string
        , body
    : IdentityUserUpdateDto | undefined 
        ,): Promise<IdentityUserDto> {
        let url_ = this.baseUrl + "/api/identity/users/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

                return request({
                            data: content_,
                                    method: "PUT",
                    url: url_,
                    header: {
                                        "Content-Type": "application/json",
                                        "Accept": "text/plain"
                            },
                }).catch((_error: any) => {
            throw _error;
        }).then((_response) => {
            return this.processUsersPut(_response);
        });
    }

    protected processUsersPut(response): Promise<IdentityUserDto> {
        const status = response.status || response.statusCode;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText.result || _responseText;
            result200 = IdentityUserDto.fromJS(resultData200, _mappings);
            return result200;
        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText.result || _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403, _mappings);
            return throwException("Forbidden", status, _responseText, _headers, result403);
        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText.result || _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401, _mappings);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText.result || _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400, _mappings);
            return throwException("Bad Request", status, _responseText, _headers, result400);
        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText.result || _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404, _mappings);
            return throwException("Not Found", status, _responseText, _headers, result404);
        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText.result || _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501, _mappings);
            return throwException("Server Error", status, _responseText, _headers, result501);
        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText.result || _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500, _mappings);
            return throwException("Server Error", status, _responseText, _headers, result500);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<IdentityUserDto>(<any>null);
    }

    /**
     * @return Success
     */
    usersDelete
    (id
    : string 
        ,): Promise<void> {
        let url_ = this.baseUrl + "/api/identity/users/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

                return request({
                                    method: "DELETE",
                    url: url_,
                    header: {
                                            },
                }).catch((_error: any) => {
            throw _error;
        }).then((_response) => {
            return this.processUsersDelete(_response);
        });
    }

    protected processUsersDelete(response): Promise<void> {
        const status = response.status || response.statusCode;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(<any>null);
        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText.result || _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403, _mappings);
            return throwException("Forbidden", status, _responseText, _headers, result403);
        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText.result || _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401, _mappings);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText.result || _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400, _mappings);
            return throwException("Bad Request", status, _responseText, _headers, result400);
        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText.result || _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404, _mappings);
            return throwException("Not Found", status, _responseText, _headers, result404);
        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText.result || _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501, _mappings);
            return throwException("Server Error", status, _responseText, _headers, result501);
        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText.result || _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500, _mappings);
            return throwException("Server Error", status, _responseText, _headers, result500);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(<any>null);
    }

    /**
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    usersGet
    (filter
    : string | undefined
        , sorting
    : string | undefined
        , skipCount
    : number | undefined
        , maxResultCount
    : number | undefined 
        ,): Promise<PagedResultDto_1OfOfIdentityUserDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null> {
        let url_ = this.baseUrl + "/api/identity/users?";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

                return request({
                                    method: "GET",
                    url: url_,
                    header: {
                                                "Accept": "text/plain"
                            },
                }).catch((_error: any) => {
            throw _error;
        }).then((_response) => {
            return this.processUsersGet(_response);
        });
    }

    protected processUsersGet(response): Promise<PagedResultDto_1OfOfIdentityUserDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null> {
        const status = response.status || response.statusCode;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText.result || _responseText;
            result200 = PagedResultDto_1OfOfIdentityUserDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null.fromJS(resultData200, _mappings);
            return result200;
        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText.result || _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403, _mappings);
            return throwException("Forbidden", status, _responseText, _headers, result403);
        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText.result || _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401, _mappings);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText.result || _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400, _mappings);
            return throwException("Bad Request", status, _responseText, _headers, result400);
        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText.result || _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404, _mappings);
            return throwException("Not Found", status, _responseText, _headers, result404);
        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText.result || _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501, _mappings);
            return throwException("Server Error", status, _responseText, _headers, result501);
        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText.result || _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500, _mappings);
            return throwException("Server Error", status, _responseText, _headers, result500);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<PagedResultDto_1OfOfIdentityUserDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    usersPost
    (body
    : IdentityUserCreateDto | undefined 
        ,): Promise<IdentityUserDto> {
        let url_ = this.baseUrl + "/api/identity/users";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

                return request({
                            data: content_,
                                    method: "POST",
                    url: url_,
                    header: {
                                        "Content-Type": "application/json",
                                        "Accept": "text/plain"
                            },
                }).catch((_error: any) => {
            throw _error;
        }).then((_response) => {
            return this.processUsersPost(_response);
        });
    }

    protected processUsersPost(response): Promise<IdentityUserDto> {
        const status = response.status || response.statusCode;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText.result || _responseText;
            result200 = IdentityUserDto.fromJS(resultData200, _mappings);
            return result200;
        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText.result || _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403, _mappings);
            return throwException("Forbidden", status, _responseText, _headers, result403);
        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText.result || _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401, _mappings);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText.result || _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400, _mappings);
            return throwException("Bad Request", status, _responseText, _headers, result400);
        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText.result || _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404, _mappings);
            return throwException("Not Found", status, _responseText, _headers, result404);
        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText.result || _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501, _mappings);
            return throwException("Server Error", status, _responseText, _headers, result501);
        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText.result || _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500, _mappings);
            return throwException("Server Error", status, _responseText, _headers, result500);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<IdentityUserDto>(<any>null);
    }
}

export class MyProfileServiceProxy extends AbpServiceBase {
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string) {
        super();
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    changePassword
    (body
    : ChangePasswordInput | undefined 
        ,): Promise<void> {
        let url_ = this.baseUrl + "/api/identity/my-profile/change-password";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

                return request({
                            data: content_,
                                    method: "POST",
                    url: url_,
                    header: {
                                        "Content-Type": "application/json",
                                    },
                }).catch((_error: any) => {
            throw _error;
        }).then((_response) => {
            return this.processChangePassword(_response);
        });
    }

    protected processChangePassword(response): Promise<void> {
        const status = response.status || response.statusCode;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(<any>null);
        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText.result || _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403, _mappings);
            return throwException("Forbidden", status, _responseText, _headers, result403);
        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText.result || _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401, _mappings);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText.result || _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400, _mappings);
            return throwException("Bad Request", status, _responseText, _headers, result400);
        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText.result || _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404, _mappings);
            return throwException("Not Found", status, _responseText, _headers, result404);
        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText.result || _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501, _mappings);
            return throwException("Server Error", status, _responseText, _headers, result501);
        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText.result || _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500, _mappings);
            return throwException("Server Error", status, _responseText, _headers, result500);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(<any>null);
    }
}

export class RolesServiceProxy extends AbpServiceBase {
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string) {
        super();
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @return Success
     */
    all
    ( ): Promise<ListResultDto_1OfOfIdentityRoleDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null> {
        let url_ = this.baseUrl + "/api/identity/roles/all";
        url_ = url_.replace(/[?&]$/, "");

                return request({
                                    method: "GET",
                    url: url_,
                    header: {
                                                "Accept": "text/plain"
                            },
                }).catch((_error: any) => {
            throw _error;
        }).then((_response) => {
            return this.processAll(_response);
        });
    }

    protected processAll(response): Promise<ListResultDto_1OfOfIdentityRoleDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null> {
        const status = response.status || response.statusCode;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText.result || _responseText;
            result200 = ListResultDto_1OfOfIdentityRoleDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null.fromJS(resultData200, _mappings);
            return result200;
        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText.result || _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403, _mappings);
            return throwException("Forbidden", status, _responseText, _headers, result403);
        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText.result || _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401, _mappings);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText.result || _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400, _mappings);
            return throwException("Bad Request", status, _responseText, _headers, result400);
        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText.result || _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404, _mappings);
            return throwException("Not Found", status, _responseText, _headers, result404);
        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText.result || _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501, _mappings);
            return throwException("Server Error", status, _responseText, _headers, result501);
        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText.result || _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500, _mappings);
            return throwException("Server Error", status, _responseText, _headers, result500);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ListResultDto_1OfOfIdentityRoleDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null>(<any>null);
    }
}

export class MultiTenancyServiceProxy extends AbpServiceBase {
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string) {
        super();
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @return Success
     */
    tenantsGet
    (id
    : string 
        ,): Promise<TenantDto> {
        let url_ = this.baseUrl + "/api/multi-tenancy/tenants/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

                return request({
                                    method: "GET",
                    url: url_,
                    header: {
                                                "Accept": "text/plain"
                            },
                }).catch((_error: any) => {
            throw _error;
        }).then((_response) => {
            return this.processTenantsGet(_response);
        });
    }

    protected processTenantsGet(response): Promise<TenantDto> {
        const status = response.status || response.statusCode;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText.result || _responseText;
            result200 = TenantDto.fromJS(resultData200, _mappings);
            return result200;
        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText.result || _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403, _mappings);
            return throwException("Forbidden", status, _responseText, _headers, result403);
        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText.result || _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401, _mappings);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText.result || _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400, _mappings);
            return throwException("Bad Request", status, _responseText, _headers, result400);
        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText.result || _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404, _mappings);
            return throwException("Not Found", status, _responseText, _headers, result404);
        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText.result || _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501, _mappings);
            return throwException("Server Error", status, _responseText, _headers, result501);
        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText.result || _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500, _mappings);
            return throwException("Server Error", status, _responseText, _headers, result500);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<TenantDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    tenantsPut
    (id
    : string
        , body
    : TenantUpdateDto | undefined 
        ,): Promise<TenantDto> {
        let url_ = this.baseUrl + "/api/multi-tenancy/tenants/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

                return request({
                            data: content_,
                                    method: "PUT",
                    url: url_,
                    header: {
                                        "Content-Type": "application/json",
                                        "Accept": "text/plain"
                            },
                }).catch((_error: any) => {
            throw _error;
        }).then((_response) => {
            return this.processTenantsPut(_response);
        });
    }

    protected processTenantsPut(response): Promise<TenantDto> {
        const status = response.status || response.statusCode;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText.result || _responseText;
            result200 = TenantDto.fromJS(resultData200, _mappings);
            return result200;
        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText.result || _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403, _mappings);
            return throwException("Forbidden", status, _responseText, _headers, result403);
        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText.result || _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401, _mappings);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText.result || _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400, _mappings);
            return throwException("Bad Request", status, _responseText, _headers, result400);
        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText.result || _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404, _mappings);
            return throwException("Not Found", status, _responseText, _headers, result404);
        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText.result || _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501, _mappings);
            return throwException("Server Error", status, _responseText, _headers, result501);
        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText.result || _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500, _mappings);
            return throwException("Server Error", status, _responseText, _headers, result500);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<TenantDto>(<any>null);
    }

    /**
     * @return Success
     */
    tenantsDelete
    (id
    : string 
        ,): Promise<void> {
        let url_ = this.baseUrl + "/api/multi-tenancy/tenants/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

                return request({
                                    method: "DELETE",
                    url: url_,
                    header: {
                                            },
                }).catch((_error: any) => {
            throw _error;
        }).then((_response) => {
            return this.processTenantsDelete(_response);
        });
    }

    protected processTenantsDelete(response): Promise<void> {
        const status = response.status || response.statusCode;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(<any>null);
        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText.result || _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403, _mappings);
            return throwException("Forbidden", status, _responseText, _headers, result403);
        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText.result || _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401, _mappings);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText.result || _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400, _mappings);
            return throwException("Bad Request", status, _responseText, _headers, result400);
        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText.result || _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404, _mappings);
            return throwException("Not Found", status, _responseText, _headers, result404);
        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText.result || _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501, _mappings);
            return throwException("Server Error", status, _responseText, _headers, result501);
        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText.result || _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500, _mappings);
            return throwException("Server Error", status, _responseText, _headers, result500);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(<any>null);
    }

    /**
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    tenantsGet
    (filter
    : string | undefined
        , sorting
    : string | undefined
        , skipCount
    : number | undefined
        , maxResultCount
    : number | undefined 
        ,): Promise<PagedResultDto_1OfOfTenantDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null> {
        let url_ = this.baseUrl + "/api/multi-tenancy/tenants?";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

                return request({
                                    method: "GET",
                    url: url_,
                    header: {
                                                "Accept": "text/plain"
                            },
                }).catch((_error: any) => {
            throw _error;
        }).then((_response) => {
            return this.processTenantsGet(_response);
        });
    }

    protected processTenantsGet(response): Promise<PagedResultDto_1OfOfTenantDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null> {
        const status = response.status || response.statusCode;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText.result || _responseText;
            result200 = PagedResultDto_1OfOfTenantDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null.fromJS(resultData200, _mappings);
            return result200;
        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText.result || _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403, _mappings);
            return throwException("Forbidden", status, _responseText, _headers, result403);
        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText.result || _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401, _mappings);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText.result || _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400, _mappings);
            return throwException("Bad Request", status, _responseText, _headers, result400);
        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText.result || _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404, _mappings);
            return throwException("Not Found", status, _responseText, _headers, result404);
        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText.result || _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501, _mappings);
            return throwException("Server Error", status, _responseText, _headers, result501);
        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText.result || _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500, _mappings);
            return throwException("Server Error", status, _responseText, _headers, result500);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<PagedResultDto_1OfOfTenantDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    tenantsPost
    (body
    : TenantCreateDto | undefined 
        ,): Promise<TenantDto> {
        let url_ = this.baseUrl + "/api/multi-tenancy/tenants";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

                return request({
                            data: content_,
                                    method: "POST",
                    url: url_,
                    header: {
                                        "Content-Type": "application/json",
                                        "Accept": "text/plain"
                            },
                }).catch((_error: any) => {
            throw _error;
        }).then((_response) => {
            return this.processTenantsPost(_response);
        });
    }

    protected processTenantsPost(response): Promise<TenantDto> {
        const status = response.status || response.statusCode;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText.result || _responseText;
            result200 = TenantDto.fromJS(resultData200, _mappings);
            return result200;
        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText.result || _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403, _mappings);
            return throwException("Forbidden", status, _responseText, _headers, result403);
        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText.result || _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401, _mappings);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText.result || _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400, _mappings);
            return throwException("Bad Request", status, _responseText, _headers, result400);
        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText.result || _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404, _mappings);
            return throwException("Not Found", status, _responseText, _headers, result404);
        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText.result || _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501, _mappings);
            return throwException("Server Error", status, _responseText, _headers, result501);
        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText.result || _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500, _mappings);
            return throwException("Server Error", status, _responseText, _headers, result500);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<TenantDto>(<any>null);
    }
}

export class UsersServiceProxy extends AbpServiceBase {
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string) {
        super();
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @return Success
     */
    rolesGet
    (id
    : string 
        ,): Promise<ListResultDto_1OfOfIdentityRoleDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null> {
        let url_ = this.baseUrl + "/api/identity/users/{id}/roles";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

                return request({
                                    method: "GET",
                    url: url_,
                    header: {
                                                "Accept": "text/plain"
                            },
                }).catch((_error: any) => {
            throw _error;
        }).then((_response) => {
            return this.processRolesGet(_response);
        });
    }

    protected processRolesGet(response): Promise<ListResultDto_1OfOfIdentityRoleDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null> {
        const status = response.status || response.statusCode;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText.result || _responseText;
            result200 = ListResultDto_1OfOfIdentityRoleDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null.fromJS(resultData200, _mappings);
            return result200;
        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText.result || _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403, _mappings);
            return throwException("Forbidden", status, _responseText, _headers, result403);
        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText.result || _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401, _mappings);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText.result || _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400, _mappings);
            return throwException("Bad Request", status, _responseText, _headers, result400);
        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText.result || _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404, _mappings);
            return throwException("Not Found", status, _responseText, _headers, result404);
        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText.result || _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501, _mappings);
            return throwException("Server Error", status, _responseText, _headers, result501);
        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText.result || _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500, _mappings);
            return throwException("Server Error", status, _responseText, _headers, result500);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ListResultDto_1OfOfIdentityRoleDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    rolesPut
    (id
    : string
        , body
    : IdentityUserUpdateRolesDto | undefined 
        ,): Promise<void> {
        let url_ = this.baseUrl + "/api/identity/users/{id}/roles";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

                return request({
                            data: content_,
                                    method: "PUT",
                    url: url_,
                    header: {
                                        "Content-Type": "application/json",
                                    },
                }).catch((_error: any) => {
            throw _error;
        }).then((_response) => {
            return this.processRolesPut(_response);
        });
    }

    protected processRolesPut(response): Promise<void> {
        const status = response.status || response.statusCode;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(<any>null);
        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText.result || _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403, _mappings);
            return throwException("Forbidden", status, _responseText, _headers, result403);
        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText.result || _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401, _mappings);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText.result || _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400, _mappings);
            return throwException("Bad Request", status, _responseText, _headers, result400);
        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText.result || _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404, _mappings);
            return throwException("Not Found", status, _responseText, _headers, result404);
        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText.result || _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501, _mappings);
            return throwException("Server Error", status, _responseText, _headers, result501);
        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText.result || _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500, _mappings);
            return throwException("Server Error", status, _responseText, _headers, result500);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(<any>null);
    }

    /**
     * @return Success
     */
    assignableRoles
    ( ): Promise<ListResultDto_1OfOfIdentityRoleDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null> {
        let url_ = this.baseUrl + "/api/identity/users/assignable-roles";
        url_ = url_.replace(/[?&]$/, "");

                return request({
                                    method: "GET",
                    url: url_,
                    header: {
                                                "Accept": "text/plain"
                            },
                }).catch((_error: any) => {
            throw _error;
        }).then((_response) => {
            return this.processAssignableRoles(_response);
        });
    }

    protected processAssignableRoles(response): Promise<ListResultDto_1OfOfIdentityRoleDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null> {
        const status = response.status || response.statusCode;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText.result || _responseText;
            result200 = ListResultDto_1OfOfIdentityRoleDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null.fromJS(resultData200, _mappings);
            return result200;
        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText.result || _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403, _mappings);
            return throwException("Forbidden", status, _responseText, _headers, result403);
        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText.result || _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401, _mappings);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText.result || _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400, _mappings);
            return throwException("Bad Request", status, _responseText, _headers, result400);
        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText.result || _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404, _mappings);
            return throwException("Not Found", status, _responseText, _headers, result404);
        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText.result || _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501, _mappings);
            return throwException("Server Error", status, _responseText, _headers, result501);
        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText.result || _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500, _mappings);
            return throwException("Server Error", status, _responseText, _headers, result500);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ListResultDto_1OfOfIdentityRoleDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null>(<any>null);
    }

    /**
     * @return Success
     */
    byUsername
    (userName
    : string 
        ,): Promise<IdentityUserDto> {
        let url_ = this.baseUrl + "/api/identity/users/by-username/{userName}";
        if (userName === undefined || userName === null)
            throw new Error("The parameter 'userName' must be defined.");
        url_ = url_.replace("{userName}", encodeURIComponent("" + userName));
        url_ = url_.replace(/[?&]$/, "");

                return request({
                                    method: "GET",
                    url: url_,
                    header: {
                                                "Accept": "text/plain"
                            },
                }).catch((_error: any) => {
            throw _error;
        }).then((_response) => {
            return this.processByUsername(_response);
        });
    }

    protected processByUsername(response): Promise<IdentityUserDto> {
        const status = response.status || response.statusCode;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText.result || _responseText;
            result200 = IdentityUserDto.fromJS(resultData200, _mappings);
            return result200;
        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText.result || _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403, _mappings);
            return throwException("Forbidden", status, _responseText, _headers, result403);
        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText.result || _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401, _mappings);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText.result || _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400, _mappings);
            return throwException("Bad Request", status, _responseText, _headers, result400);
        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText.result || _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404, _mappings);
            return throwException("Not Found", status, _responseText, _headers, result404);
        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText.result || _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501, _mappings);
            return throwException("Server Error", status, _responseText, _headers, result501);
        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText.result || _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500, _mappings);
            return throwException("Server Error", status, _responseText, _headers, result500);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<IdentityUserDto>(<any>null);
    }

    /**
     * @return Success
     */
    byEmail
    (email
    : string 
        ,): Promise<IdentityUserDto> {
        let url_ = this.baseUrl + "/api/identity/users/by-email/{email}";
        if (email === undefined || email === null)
            throw new Error("The parameter 'email' must be defined.");
        url_ = url_.replace("{email}", encodeURIComponent("" + email));
        url_ = url_.replace(/[?&]$/, "");

                return request({
                                    method: "GET",
                    url: url_,
                    header: {
                                                "Accept": "text/plain"
                            },
                }).catch((_error: any) => {
            throw _error;
        }).then((_response) => {
            return this.processByEmail(_response);
        });
    }

    protected processByEmail(response): Promise<IdentityUserDto> {
        const status = response.status || response.statusCode;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText.result || _responseText;
            result200 = IdentityUserDto.fromJS(resultData200, _mappings);
            return result200;
        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText.result || _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403, _mappings);
            return throwException("Forbidden", status, _responseText, _headers, result403);
        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText.result || _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401, _mappings);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText.result || _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400, _mappings);
            return throwException("Bad Request", status, _responseText, _headers, result400);
        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText.result || _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404, _mappings);
            return throwException("Not Found", status, _responseText, _headers, result404);
        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText.result || _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501, _mappings);
            return throwException("Server Error", status, _responseText, _headers, result501);
        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText.result || _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500, _mappings);
            return throwException("Server Error", status, _responseText, _headers, result500);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<IdentityUserDto>(<any>null);
    }

    /**
     * @return Success
     */
    lookup
    (id
    : string 
        ,): Promise<UserData> {
        let url_ = this.baseUrl + "/api/identity/users/lookup/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

                return request({
                                    method: "GET",
                    url: url_,
                    header: {
                                                "Accept": "text/plain"
                            },
                }).catch((_error: any) => {
            throw _error;
        }).then((_response) => {
            return this.processLookup(_response);
        });
    }

    protected processLookup(response): Promise<UserData> {
        const status = response.status || response.statusCode;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText.result || _responseText;
            result200 = UserData.fromJS(resultData200, _mappings);
            return result200;
        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText.result || _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403, _mappings);
            return throwException("Forbidden", status, _responseText, _headers, result403);
        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText.result || _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401, _mappings);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText.result || _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400, _mappings);
            return throwException("Bad Request", status, _responseText, _headers, result400);
        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText.result || _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404, _mappings);
            return throwException("Not Found", status, _responseText, _headers, result404);
        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText.result || _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501, _mappings);
            return throwException("Server Error", status, _responseText, _headers, result501);
        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText.result || _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500, _mappings);
            return throwException("Server Error", status, _responseText, _headers, result500);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<UserData>(<any>null);
    }
}

export class LookupServiceProxy extends AbpServiceBase {
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string) {
        super();
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @return Success
     */
    byUsername
    (userName
    : string 
        ,): Promise<UserData> {
        let url_ = this.baseUrl + "/api/identity/users/lookup/by-username/{userName}";
        if (userName === undefined || userName === null)
            throw new Error("The parameter 'userName' must be defined.");
        url_ = url_.replace("{userName}", encodeURIComponent("" + userName));
        url_ = url_.replace(/[?&]$/, "");

                return request({
                                    method: "GET",
                    url: url_,
                    header: {
                                                "Accept": "text/plain"
                            },
                }).catch((_error: any) => {
            throw _error;
        }).then((_response) => {
            return this.processByUsername(_response);
        });
    }

    protected processByUsername(response): Promise<UserData> {
        const status = response.status || response.statusCode;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText.result || _responseText;
            result200 = UserData.fromJS(resultData200, _mappings);
            return result200;
        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText.result || _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403, _mappings);
            return throwException("Forbidden", status, _responseText, _headers, result403);
        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText.result || _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401, _mappings);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText.result || _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400, _mappings);
            return throwException("Bad Request", status, _responseText, _headers, result400);
        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText.result || _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404, _mappings);
            return throwException("Not Found", status, _responseText, _headers, result404);
        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText.result || _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501, _mappings);
            return throwException("Server Error", status, _responseText, _headers, result501);
        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText.result || _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500, _mappings);
            return throwException("Server Error", status, _responseText, _headers, result500);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<UserData>(<any>null);
    }

    /**
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    search
    (filter
    : string | undefined
        , sorting
    : string | undefined
        , skipCount
    : number | undefined
        , maxResultCount
    : number | undefined 
        ,): Promise<ListResultDto_1OfOfUserDataAndAbstractionsAnd_0AndCulture_neutralAndPublicKeyToken_null> {
        let url_ = this.baseUrl + "/api/identity/users/lookup/search?";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

                return request({
                                    method: "GET",
                    url: url_,
                    header: {
                                                "Accept": "text/plain"
                            },
                }).catch((_error: any) => {
            throw _error;
        }).then((_response) => {
            return this.processSearch(_response);
        });
    }

    protected processSearch(response): Promise<ListResultDto_1OfOfUserDataAndAbstractionsAnd_0AndCulture_neutralAndPublicKeyToken_null> {
        const status = response.status || response.statusCode;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText.result || _responseText;
            result200 = ListResultDto_1OfOfUserDataAndAbstractionsAnd_0AndCulture_neutralAndPublicKeyToken_null.fromJS(resultData200, _mappings);
            return result200;
        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText.result || _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403, _mappings);
            return throwException("Forbidden", status, _responseText, _headers, result403);
        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText.result || _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401, _mappings);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText.result || _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400, _mappings);
            return throwException("Bad Request", status, _responseText, _headers, result400);
        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText.result || _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404, _mappings);
            return throwException("Not Found", status, _responseText, _headers, result404);
        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText.result || _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501, _mappings);
            return throwException("Server Error", status, _responseText, _headers, result501);
        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText.result || _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500, _mappings);
            return throwException("Server Error", status, _responseText, _headers, result500);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ListResultDto_1OfOfUserDataAndAbstractionsAnd_0AndCulture_neutralAndPublicKeyToken_null>(<any>null);
    }

    /**
     * @param filter (optional) 
     * @return Success
     */
    count
    (filter
    : string | undefined 
        ,): Promise<number> {
        let url_ = this.baseUrl + "/api/identity/users/lookup/count?";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        url_ = url_.replace(/[?&]$/, "");

                return request({
                                    method: "GET",
                    url: url_,
                    header: {
                                                "Accept": "text/plain"
                            },
                }).catch((_error: any) => {
            throw _error;
        }).then((_response) => {
            return this.processCount(_response);
        });
    }

    protected processCount(response): Promise<number> {
        const status = response.status || response.statusCode;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText.result || _responseText;
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return result200;
        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText.result || _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403, _mappings);
            return throwException("Forbidden", status, _responseText, _headers, result403);
        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText.result || _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401, _mappings);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText.result || _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400, _mappings);
            return throwException("Bad Request", status, _responseText, _headers, result400);
        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText.result || _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404, _mappings);
            return throwException("Not Found", status, _responseText, _headers, result404);
        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText.result || _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501, _mappings);
            return throwException("Server Error", status, _responseText, _headers, result501);
        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText.result || _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500, _mappings);
            return throwException("Server Error", status, _responseText, _headers, result500);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<number>(<any>null);
    }
}

export class AccountCreateUpdateDto {
    title!: string;
    currencyCode!: string;
    note!: string | null;
    balance!: number | null;
    includeInTotals!: boolean | null;

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.title = _data["title"] !== undefined ? _data["title"] : <any>null;
            this.currencyCode = _data["currencyCode"] !== undefined ? _data["currencyCode"] : <any>null;
            this.note = _data["note"] !== undefined ? _data["note"] : <any>null;
            this.balance = _data["balance"] !== undefined ? _data["balance"] : <any>null;
            this.includeInTotals = _data["includeInTotals"] !== undefined ? _data["includeInTotals"] : <any>null;
        }
    }

    static fromJS(data: any, _mappings?: any): AccountCreateUpdateDto | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<AccountCreateUpdateDto>(data, _mappings, AccountCreateUpdateDto);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["title"] = this.title !== undefined ? this.title : <any>null;
        data["currencyCode"] = this.currencyCode !== undefined ? this.currencyCode : <any>null;
        data["note"] = this.note !== undefined ? this.note : <any>null;
        data["balance"] = this.balance !== undefined ? this.balance : <any>null;
        data["includeInTotals"] = this.includeInTotals !== undefined ? this.includeInTotals : <any>null;
        return data; 
    }
}

export class AccountDto {
    id!: string;
    currencyCode!: string | null;
    currency!: CurrencyDto;
    title!: string | null;
    note!: string | null;
    balance!: number | null;
    includeInTotals!: boolean | null;

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.id = _data["id"] !== undefined ? _data["id"] : <any>null;
            this.currencyCode = _data["currencyCode"] !== undefined ? _data["currencyCode"] : <any>null;
            this.currency = _data["currency"] ? CurrencyDto.fromJS(_data["currency"], _mappings) : <any>null;
            this.title = _data["title"] !== undefined ? _data["title"] : <any>null;
            this.note = _data["note"] !== undefined ? _data["note"] : <any>null;
            this.balance = _data["balance"] !== undefined ? _data["balance"] : <any>null;
            this.includeInTotals = _data["includeInTotals"] !== undefined ? _data["includeInTotals"] : <any>null;
        }
    }

    static fromJS(data: any, _mappings?: any): AccountDto | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<AccountDto>(data, _mappings, AccountDto);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["currencyCode"] = this.currencyCode !== undefined ? this.currencyCode : <any>null;
        data["currency"] = this.currency ? this.currency.toJSON() : <any>null;
        data["title"] = this.title !== undefined ? this.title : <any>null;
        data["note"] = this.note !== undefined ? this.note : <any>null;
        data["balance"] = this.balance !== undefined ? this.balance : <any>null;
        data["includeInTotals"] = this.includeInTotals !== undefined ? this.includeInTotals : <any>null;
        return data; 
    }
}

export class CategoryCreateUpdateDto {
    title!: string;
    color!: number | null;
    transactionType!: TransactionType;
    sortOrder!: number | null;

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.title = _data["title"] !== undefined ? _data["title"] : <any>null;
            this.color = _data["color"] !== undefined ? _data["color"] : <any>null;
            this.transactionType = _data["transactionType"] !== undefined ? _data["transactionType"] : <any>null;
            this.sortOrder = _data["sortOrder"] !== undefined ? _data["sortOrder"] : <any>null;
        }
    }

    static fromJS(data: any, _mappings?: any): CategoryCreateUpdateDto | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<CategoryCreateUpdateDto>(data, _mappings, CategoryCreateUpdateDto);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["title"] = this.title !== undefined ? this.title : <any>null;
        data["color"] = this.color !== undefined ? this.color : <any>null;
        data["transactionType"] = this.transactionType !== undefined ? this.transactionType : <any>null;
        data["sortOrder"] = this.sortOrder !== undefined ? this.sortOrder : <any>null;
        return data; 
    }
}

export class CategoryDto {
    id!: string;
    title!: string;
    color!: number | null;
    transactionType!: TransactionType;
    sortOrder!: number | null;

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.id = _data["id"] !== undefined ? _data["id"] : <any>null;
            this.title = _data["title"] !== undefined ? _data["title"] : <any>null;
            this.color = _data["color"] !== undefined ? _data["color"] : <any>null;
            this.transactionType = _data["transactionType"] !== undefined ? _data["transactionType"] : <any>null;
            this.sortOrder = _data["sortOrder"] !== undefined ? _data["sortOrder"] : <any>null;
        }
    }

    static fromJS(data: any, _mappings?: any): CategoryDto | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<CategoryDto>(data, _mappings, CategoryDto);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["title"] = this.title !== undefined ? this.title : <any>null;
        data["color"] = this.color !== undefined ? this.color : <any>null;
        data["transactionType"] = this.transactionType !== undefined ? this.transactionType : <any>null;
        data["sortOrder"] = this.sortOrder !== undefined ? this.sortOrder : <any>null;
        return data; 
    }
}

export class CreateUpdateTransactionDto {
    category!: CategoryDto;
    accountFrom!: AccountDto;
    accountTo!: AccountDto;
    tags!: TagDto[] | null;
    date!: Date;
    amount!: number;
    exchangeRate!: number | null;
    note!: string | null;
    transactionState!: boolean | null;
    transactionType!: TransactionType;
    includeInReports!: boolean | null;
    attachments!: TransactionAttachmentDto[] | null;

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.category = _data["category"] ? CategoryDto.fromJS(_data["category"], _mappings) : <any>null;
            this.accountFrom = _data["accountFrom"] ? AccountDto.fromJS(_data["accountFrom"], _mappings) : <any>null;
            this.accountTo = _data["accountTo"] ? AccountDto.fromJS(_data["accountTo"], _mappings) : <any>null;
            if (Array.isArray(_data["tags"])) {
                this.tags = [] as any;
                for (let item of _data["tags"])
                    this.tags!.push(TagDto.fromJS(item, _mappings));
            }
            else {
                this.tags = <any>null;
            }
            this.date = _data["date"] ? new Date(_data["date"].toString()) : <any>null;
            this.amount = _data["amount"] !== undefined ? _data["amount"] : <any>null;
            this.exchangeRate = _data["exchangeRate"] !== undefined ? _data["exchangeRate"] : <any>null;
            this.note = _data["note"] !== undefined ? _data["note"] : <any>null;
            this.transactionState = _data["transactionState"] !== undefined ? _data["transactionState"] : <any>null;
            this.transactionType = _data["transactionType"] !== undefined ? _data["transactionType"] : <any>null;
            this.includeInReports = _data["includeInReports"] !== undefined ? _data["includeInReports"] : <any>null;
            if (Array.isArray(_data["attachments"])) {
                this.attachments = [] as any;
                for (let item of _data["attachments"])
                    this.attachments!.push(TransactionAttachmentDto.fromJS(item, _mappings));
            }
            else {
                this.attachments = <any>null;
            }
        }
    }

    static fromJS(data: any, _mappings?: any): CreateUpdateTransactionDto | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<CreateUpdateTransactionDto>(data, _mappings, CreateUpdateTransactionDto);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["category"] = this.category ? this.category.toJSON() : <any>null;
        data["accountFrom"] = this.accountFrom ? this.accountFrom.toJSON() : <any>null;
        data["accountTo"] = this.accountTo ? this.accountTo.toJSON() : <any>null;
        if (Array.isArray(this.tags)) {
            data["tags"] = [];
            for (let item of this.tags)
                data["tags"].push(item.toJSON());
        }
        data["date"] = this.date ? this.date.toISOString() : <any>null;
        data["amount"] = this.amount !== undefined ? this.amount : <any>null;
        data["exchangeRate"] = this.exchangeRate !== undefined ? this.exchangeRate : <any>null;
        data["note"] = this.note !== undefined ? this.note : <any>null;
        data["transactionState"] = this.transactionState !== undefined ? this.transactionState : <any>null;
        data["transactionType"] = this.transactionType !== undefined ? this.transactionType : <any>null;
        data["includeInReports"] = this.includeInReports !== undefined ? this.includeInReports : <any>null;
        if (Array.isArray(this.attachments)) {
            data["attachments"] = [];
            for (let item of this.attachments)
                data["attachments"].push(item.toJSON());
        }
        return data; 
    }
}

export class CurrencyDto {
    id!: string | null;
    code!: string | null;
    currencyRate!: RateDto[] | null;
    symbol!: string | null;
    symbolPosition!: SymbolPositionType;
    decimalSeparator!: string | null;
    groupSeparator!: string | null;
    decimalCount!: number;

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.id = _data["id"] !== undefined ? _data["id"] : <any>null;
            this.code = _data["code"] !== undefined ? _data["code"] : <any>null;
            if (Array.isArray(_data["currencyRate"])) {
                this.currencyRate = [] as any;
                for (let item of _data["currencyRate"])
                    this.currencyRate!.push(RateDto.fromJS(item, _mappings));
            }
            else {
                this.currencyRate = <any>null;
            }
            this.symbol = _data["symbol"] !== undefined ? _data["symbol"] : <any>null;
            this.symbolPosition = _data["symbolPosition"] !== undefined ? _data["symbolPosition"] : <any>null;
            this.decimalSeparator = _data["decimalSeparator"] !== undefined ? _data["decimalSeparator"] : <any>null;
            this.groupSeparator = _data["groupSeparator"] !== undefined ? _data["groupSeparator"] : <any>null;
            this.decimalCount = _data["decimalCount"] !== undefined ? _data["decimalCount"] : <any>null;
        }
    }

    static fromJS(data: any, _mappings?: any): CurrencyDto | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<CurrencyDto>(data, _mappings, CurrencyDto);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["code"] = this.code !== undefined ? this.code : <any>null;
        if (Array.isArray(this.currencyRate)) {
            data["currencyRate"] = [];
            for (let item of this.currencyRate)
                data["currencyRate"].push(item.toJSON());
        }
        data["symbol"] = this.symbol !== undefined ? this.symbol : <any>null;
        data["symbolPosition"] = this.symbolPosition !== undefined ? this.symbolPosition : <any>null;
        data["decimalSeparator"] = this.decimalSeparator !== undefined ? this.decimalSeparator : <any>null;
        data["groupSeparator"] = this.groupSeparator !== undefined ? this.groupSeparator : <any>null;
        data["decimalCount"] = this.decimalCount !== undefined ? this.decimalCount : <any>null;
        return data; 
    }
}

export class RateDto {
    toCode!: string | null;
    ratio!: number;

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.toCode = _data["toCode"] !== undefined ? _data["toCode"] : <any>null;
            this.ratio = _data["ratio"] !== undefined ? _data["ratio"] : <any>null;
        }
    }

    static fromJS(data: any, _mappings?: any): RateDto | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<RateDto>(data, _mappings, RateDto);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["toCode"] = this.toCode !== undefined ? this.toCode : <any>null;
        data["ratio"] = this.ratio !== undefined ? this.ratio : <any>null;
        return data; 
    }
}

export class TagCreateUpdateDto {
    title!: string;

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.title = _data["title"] !== undefined ? _data["title"] : <any>null;
        }
    }

    static fromJS(data: any, _mappings?: any): TagCreateUpdateDto | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<TagCreateUpdateDto>(data, _mappings, TagCreateUpdateDto);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["title"] = this.title !== undefined ? this.title : <any>null;
        return data; 
    }
}

export class TagDto {
    id!: string;
    title!: string | null;

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.id = _data["id"] !== undefined ? _data["id"] : <any>null;
            this.title = _data["title"] !== undefined ? _data["title"] : <any>null;
        }
    }

    static fromJS(data: any, _mappings?: any): TagDto | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<TagDto>(data, _mappings, TagDto);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["title"] = this.title !== undefined ? this.title : <any>null;
        return data; 
    }
}

export class TransactionAttachmentCreateUpdateDto {
    title!: string | null;
    size!: number;
    index!: number;
    url!: string | null;

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.title = _data["title"] !== undefined ? _data["title"] : <any>null;
            this.size = _data["size"] !== undefined ? _data["size"] : <any>null;
            this.index = _data["index"] !== undefined ? _data["index"] : <any>null;
            this.url = _data["url"] !== undefined ? _data["url"] : <any>null;
        }
    }

    static fromJS(data: any, _mappings?: any): TransactionAttachmentCreateUpdateDto | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<TransactionAttachmentCreateUpdateDto>(data, _mappings, TransactionAttachmentCreateUpdateDto);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["title"] = this.title !== undefined ? this.title : <any>null;
        data["size"] = this.size !== undefined ? this.size : <any>null;
        data["index"] = this.index !== undefined ? this.index : <any>null;
        data["url"] = this.url !== undefined ? this.url : <any>null;
        return data; 
    }
}

export class TransactionAttachmentDto {
    id!: string;
    creationTime!: Date;
    creatorId!: string | null;
    lastModificationTime!: Date | null;
    lastModifierId!: string | null;
    isDeleted!: boolean;
    deleterId!: string | null;
    deletionTime!: Date | null;
    title!: string | null;
    size!: number;
    index!: number;
    url!: string | null;

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.id = _data["id"] !== undefined ? _data["id"] : <any>null;
            this.creationTime = _data["creationTime"] ? new Date(_data["creationTime"].toString()) : <any>null;
            this.creatorId = _data["creatorId"] !== undefined ? _data["creatorId"] : <any>null;
            this.lastModificationTime = _data["lastModificationTime"] ? new Date(_data["lastModificationTime"].toString()) : <any>null;
            this.lastModifierId = _data["lastModifierId"] !== undefined ? _data["lastModifierId"] : <any>null;
            this.isDeleted = _data["isDeleted"] !== undefined ? _data["isDeleted"] : <any>null;
            this.deleterId = _data["deleterId"] !== undefined ? _data["deleterId"] : <any>null;
            this.deletionTime = _data["deletionTime"] ? new Date(_data["deletionTime"].toString()) : <any>null;
            this.title = _data["title"] !== undefined ? _data["title"] : <any>null;
            this.size = _data["size"] !== undefined ? _data["size"] : <any>null;
            this.index = _data["index"] !== undefined ? _data["index"] : <any>null;
            this.url = _data["url"] !== undefined ? _data["url"] : <any>null;
        }
    }

    static fromJS(data: any, _mappings?: any): TransactionAttachmentDto | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<TransactionAttachmentDto>(data, _mappings, TransactionAttachmentDto);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>null;
        data["creatorId"] = this.creatorId !== undefined ? this.creatorId : <any>null;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>null;
        data["lastModifierId"] = this.lastModifierId !== undefined ? this.lastModifierId : <any>null;
        data["isDeleted"] = this.isDeleted !== undefined ? this.isDeleted : <any>null;
        data["deleterId"] = this.deleterId !== undefined ? this.deleterId : <any>null;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>null;
        data["title"] = this.title !== undefined ? this.title : <any>null;
        data["size"] = this.size !== undefined ? this.size : <any>null;
        data["index"] = this.index !== undefined ? this.index : <any>null;
        data["url"] = this.url !== undefined ? this.url : <any>null;
        return data; 
    }
}

export class TransactionDto {
    id!: string;
    accountFrom!: AccountDto;
    accountFromId!: string | null;
    accountToId!: string | null;
    categoryId!: string | null;
    accountTo!: AccountDto;
    category!: CategoryDto;
    tags!: TagDto[] | null;
    date!: Date | null;
    amount!: number;
    exchangeRate!: number | null;
    note!: string | null;
    transactionState!: boolean;
    transactionType!: TransactionType;
    transactionTypeDescription!: string | null;
    includeInReports!: boolean;
    attachments!: TransactionAttachmentDto[] | null;

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.id = _data["id"] !== undefined ? _data["id"] : <any>null;
            this.accountFrom = _data["accountFrom"] ? AccountDto.fromJS(_data["accountFrom"], _mappings) : <any>null;
            this.accountFromId = _data["accountFromId"] !== undefined ? _data["accountFromId"] : <any>null;
            this.accountToId = _data["accountToId"] !== undefined ? _data["accountToId"] : <any>null;
            this.categoryId = _data["categoryId"] !== undefined ? _data["categoryId"] : <any>null;
            this.accountTo = _data["accountTo"] ? AccountDto.fromJS(_data["accountTo"], _mappings) : <any>null;
            this.category = _data["category"] ? CategoryDto.fromJS(_data["category"], _mappings) : <any>null;
            if (Array.isArray(_data["tags"])) {
                this.tags = [] as any;
                for (let item of _data["tags"])
                    this.tags!.push(TagDto.fromJS(item, _mappings));
            }
            else {
                this.tags = <any>null;
            }
            this.date = _data["date"] ? new Date(_data["date"].toString()) : <any>null;
            this.amount = _data["amount"] !== undefined ? _data["amount"] : <any>null;
            this.exchangeRate = _data["exchangeRate"] !== undefined ? _data["exchangeRate"] : <any>null;
            this.note = _data["note"] !== undefined ? _data["note"] : <any>null;
            this.transactionState = _data["transactionState"] !== undefined ? _data["transactionState"] : <any>null;
            this.transactionType = _data["transactionType"] !== undefined ? _data["transactionType"] : <any>null;
            this.transactionTypeDescription = _data["transactionTypeDescription"] !== undefined ? _data["transactionTypeDescription"] : <any>null;
            this.includeInReports = _data["includeInReports"] !== undefined ? _data["includeInReports"] : <any>null;
            if (Array.isArray(_data["attachments"])) {
                this.attachments = [] as any;
                for (let item of _data["attachments"])
                    this.attachments!.push(TransactionAttachmentDto.fromJS(item, _mappings));
            }
            else {
                this.attachments = <any>null;
            }
        }
    }

    static fromJS(data: any, _mappings?: any): TransactionDto | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<TransactionDto>(data, _mappings, TransactionDto);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["accountFrom"] = this.accountFrom ? this.accountFrom.toJSON() : <any>null;
        data["accountFromId"] = this.accountFromId !== undefined ? this.accountFromId : <any>null;
        data["accountToId"] = this.accountToId !== undefined ? this.accountToId : <any>null;
        data["categoryId"] = this.categoryId !== undefined ? this.categoryId : <any>null;
        data["accountTo"] = this.accountTo ? this.accountTo.toJSON() : <any>null;
        data["category"] = this.category ? this.category.toJSON() : <any>null;
        if (Array.isArray(this.tags)) {
            data["tags"] = [];
            for (let item of this.tags)
                data["tags"].push(item.toJSON());
        }
        data["date"] = this.date ? this.date.toISOString() : <any>null;
        data["amount"] = this.amount !== undefined ? this.amount : <any>null;
        data["exchangeRate"] = this.exchangeRate !== undefined ? this.exchangeRate : <any>null;
        data["note"] = this.note !== undefined ? this.note : <any>null;
        data["transactionState"] = this.transactionState !== undefined ? this.transactionState : <any>null;
        data["transactionType"] = this.transactionType !== undefined ? this.transactionType : <any>null;
        data["transactionTypeDescription"] = this.transactionTypeDescription !== undefined ? this.transactionTypeDescription : <any>null;
        data["includeInReports"] = this.includeInReports !== undefined ? this.includeInReports : <any>null;
        if (Array.isArray(this.attachments)) {
            data["attachments"] = [];
            for (let item of this.attachments)
                data["attachments"].push(item.toJSON());
        }
        return data; 
    }
}

export enum SymbolPositionType {
    _1 = 1,
    _2 = 2,
}

export enum TransactionType {
    _1 = 1,
    _2 = 2,
    _3 = 3,
}

export class RegisterDto {
    readonly extraProperties!: { [key: string]: any; } | null;
    userName!: string;
    emailAddress!: string;
    password!: string;
    appName!: string;

    init(_data?: any, _mappings?: any) {
        if (_data) {
            if (_data["extraProperties"]) {
                (<any>this).extraProperties = {} as any;
                for (let key in _data["extraProperties"]) {
                    if (_data["extraProperties"].hasOwnProperty(key))
                        (<any>(<any>this).extraProperties)![key] = _data["extraProperties"][key];
                }
            }
            else {
                (<any>this).extraProperties = <any>null;
            }
            this.userName = _data["userName"] !== undefined ? _data["userName"] : <any>null;
            this.emailAddress = _data["emailAddress"] !== undefined ? _data["emailAddress"] : <any>null;
            this.password = _data["password"] !== undefined ? _data["password"] : <any>null;
            this.appName = _data["appName"] !== undefined ? _data["appName"] : <any>null;
        }
    }

    static fromJS(data: any, _mappings?: any): RegisterDto | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<RegisterDto>(data, _mappings, RegisterDto);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.extraProperties) {
            data["extraProperties"] = {};
            for (let key in this.extraProperties) {
                if (this.extraProperties.hasOwnProperty(key))
                    (<any>data["extraProperties"])[key] = this.extraProperties[key] !== undefined ? this.extraProperties[key] : <any>null;
            }
        }
        data["userName"] = this.userName !== undefined ? this.userName : <any>null;
        data["emailAddress"] = this.emailAddress !== undefined ? this.emailAddress : <any>null;
        data["password"] = this.password !== undefined ? this.password : <any>null;
        data["appName"] = this.appName !== undefined ? this.appName : <any>null;
        return data; 
    }
}

export class ResetPasswordDto {
    userId!: string;
    resetToken!: string;
    password!: string;

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.userId = _data["userId"] !== undefined ? _data["userId"] : <any>null;
            this.resetToken = _data["resetToken"] !== undefined ? _data["resetToken"] : <any>null;
            this.password = _data["password"] !== undefined ? _data["password"] : <any>null;
        }
    }

    static fromJS(data: any, _mappings?: any): ResetPasswordDto | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<ResetPasswordDto>(data, _mappings, ResetPasswordDto);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId !== undefined ? this.userId : <any>null;
        data["resetToken"] = this.resetToken !== undefined ? this.resetToken : <any>null;
        data["password"] = this.password !== undefined ? this.password : <any>null;
        return data; 
    }
}

export class SendPasswordResetCodeDto {
    email!: string;
    appName!: string;
    returnUrl!: string | null;
    returnUrlHash!: string | null;

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.email = _data["email"] !== undefined ? _data["email"] : <any>null;
            this.appName = _data["appName"] !== undefined ? _data["appName"] : <any>null;
            this.returnUrl = _data["returnUrl"] !== undefined ? _data["returnUrl"] : <any>null;
            this.returnUrlHash = _data["returnUrlHash"] !== undefined ? _data["returnUrlHash"] : <any>null;
        }
    }

    static fromJS(data: any, _mappings?: any): SendPasswordResetCodeDto | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<SendPasswordResetCodeDto>(data, _mappings, SendPasswordResetCodeDto);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["email"] = this.email !== undefined ? this.email : <any>null;
        data["appName"] = this.appName !== undefined ? this.appName : <any>null;
        data["returnUrl"] = this.returnUrl !== undefined ? this.returnUrl : <any>null;
        data["returnUrlHash"] = this.returnUrlHash !== undefined ? this.returnUrlHash : <any>null;
        return data; 
    }
}

export class AbpLoginResult {
    result!: LoginResultType;
    readonly description!: string | null;

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.result = _data["result"] !== undefined ? _data["result"] : <any>null;
            (<any>this).description = _data["description"] !== undefined ? _data["description"] : <any>null;
        }
    }

    static fromJS(data: any, _mappings?: any): AbpLoginResult | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<AbpLoginResult>(data, _mappings, AbpLoginResult);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["result"] = this.result !== undefined ? this.result : <any>null;
        data["description"] = this.description !== undefined ? this.description : <any>null;
        return data; 
    }
}

export enum LoginResultType {
    _1 = 1,
    _2 = 2,
    _3 = 3,
    _4 = 4,
    _5 = 5,
}

export class UserLoginInfo {
    userNameOrEmailAddress!: string;
    password!: string;
    rememberMe!: boolean;

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.userNameOrEmailAddress = _data["userNameOrEmailAddress"] !== undefined ? _data["userNameOrEmailAddress"] : <any>null;
            this.password = _data["password"] !== undefined ? _data["password"] : <any>null;
            this.rememberMe = _data["rememberMe"] !== undefined ? _data["rememberMe"] : <any>null;
        }
    }

    static fromJS(data: any, _mappings?: any): UserLoginInfo | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<UserLoginInfo>(data, _mappings, UserLoginInfo);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userNameOrEmailAddress"] = this.userNameOrEmailAddress !== undefined ? this.userNameOrEmailAddress : <any>null;
        data["password"] = this.password !== undefined ? this.password : <any>null;
        data["rememberMe"] = this.rememberMe !== undefined ? this.rememberMe : <any>null;
        return data; 
    }
}

export class ListResultDto_1OfOfIdentityRoleDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null {
    items!: IdentityRoleDto[] | null;

    init(_data?: any, _mappings?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(IdentityRoleDto.fromJS(item, _mappings));
            }
            else {
                this.items = <any>null;
            }
        }
    }

    static fromJS(data: any, _mappings?: any): ListResultDto_1OfOfIdentityRoleDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<ListResultDto_1OfOfIdentityRoleDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null>(data, _mappings, ListResultDto_1OfOfIdentityRoleDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export class ListResultDto_1OfOfUserDataAndAbstractionsAnd_0AndCulture_neutralAndPublicKeyToken_null {
    items!: UserData[] | null;

    init(_data?: any, _mappings?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(UserData.fromJS(item, _mappings));
            }
            else {
                this.items = <any>null;
            }
        }
    }

    static fromJS(data: any, _mappings?: any): ListResultDto_1OfOfUserDataAndAbstractionsAnd_0AndCulture_neutralAndPublicKeyToken_null | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<ListResultDto_1OfOfUserDataAndAbstractionsAnd_0AndCulture_neutralAndPublicKeyToken_null>(data, _mappings, ListResultDto_1OfOfUserDataAndAbstractionsAnd_0AndCulture_neutralAndPublicKeyToken_null);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export class PagedResultDto_1OfOfAccountDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null {
    items!: AccountDto[] | null;
    totalCount!: number;

    init(_data?: any, _mappings?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(AccountDto.fromJS(item, _mappings));
            }
            else {
                this.items = <any>null;
            }
            this.totalCount = _data["totalCount"] !== undefined ? _data["totalCount"] : <any>null;
        }
    }

    static fromJS(data: any, _mappings?: any): PagedResultDto_1OfOfAccountDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<PagedResultDto_1OfOfAccountDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null>(data, _mappings, PagedResultDto_1OfOfAccountDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount !== undefined ? this.totalCount : <any>null;
        return data; 
    }
}

export class PagedResultDto_1OfOfCategoryDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null {
    items!: CategoryDto[] | null;
    totalCount!: number;

    init(_data?: any, _mappings?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(CategoryDto.fromJS(item, _mappings));
            }
            else {
                this.items = <any>null;
            }
            this.totalCount = _data["totalCount"] !== undefined ? _data["totalCount"] : <any>null;
        }
    }

    static fromJS(data: any, _mappings?: any): PagedResultDto_1OfOfCategoryDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<PagedResultDto_1OfOfCategoryDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null>(data, _mappings, PagedResultDto_1OfOfCategoryDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount !== undefined ? this.totalCount : <any>null;
        return data; 
    }
}

export class PagedResultDto_1OfOfCurrencyDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null {
    items!: CurrencyDto[] | null;
    totalCount!: number;

    init(_data?: any, _mappings?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(CurrencyDto.fromJS(item, _mappings));
            }
            else {
                this.items = <any>null;
            }
            this.totalCount = _data["totalCount"] !== undefined ? _data["totalCount"] : <any>null;
        }
    }

    static fromJS(data: any, _mappings?: any): PagedResultDto_1OfOfCurrencyDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<PagedResultDto_1OfOfCurrencyDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null>(data, _mappings, PagedResultDto_1OfOfCurrencyDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount !== undefined ? this.totalCount : <any>null;
        return data; 
    }
}

export class PagedResultDto_1OfOfTagDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null {
    items!: TagDto[] | null;
    totalCount!: number;

    init(_data?: any, _mappings?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(TagDto.fromJS(item, _mappings));
            }
            else {
                this.items = <any>null;
            }
            this.totalCount = _data["totalCount"] !== undefined ? _data["totalCount"] : <any>null;
        }
    }

    static fromJS(data: any, _mappings?: any): PagedResultDto_1OfOfTagDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<PagedResultDto_1OfOfTagDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null>(data, _mappings, PagedResultDto_1OfOfTagDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount !== undefined ? this.totalCount : <any>null;
        return data; 
    }
}

export class PagedResultDto_1OfOfTransactionAttachmentDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null {
    items!: TransactionAttachmentDto[] | null;
    totalCount!: number;

    init(_data?: any, _mappings?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(TransactionAttachmentDto.fromJS(item, _mappings));
            }
            else {
                this.items = <any>null;
            }
            this.totalCount = _data["totalCount"] !== undefined ? _data["totalCount"] : <any>null;
        }
    }

    static fromJS(data: any, _mappings?: any): PagedResultDto_1OfOfTransactionAttachmentDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<PagedResultDto_1OfOfTransactionAttachmentDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null>(data, _mappings, PagedResultDto_1OfOfTransactionAttachmentDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount !== undefined ? this.totalCount : <any>null;
        return data; 
    }
}

export class PagedResultDto_1OfOfTransactionDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null {
    items!: TransactionDto[] | null;
    totalCount!: number;

    init(_data?: any, _mappings?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(TransactionDto.fromJS(item, _mappings));
            }
            else {
                this.items = <any>null;
            }
            this.totalCount = _data["totalCount"] !== undefined ? _data["totalCount"] : <any>null;
        }
    }

    static fromJS(data: any, _mappings?: any): PagedResultDto_1OfOfTransactionDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<PagedResultDto_1OfOfTransactionDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null>(data, _mappings, PagedResultDto_1OfOfTransactionDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount !== undefined ? this.totalCount : <any>null;
        return data; 
    }
}

export class PagedResultDto_1OfOfIdentityRoleDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null {
    items!: IdentityRoleDto[] | null;
    totalCount!: number;

    init(_data?: any, _mappings?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(IdentityRoleDto.fromJS(item, _mappings));
            }
            else {
                this.items = <any>null;
            }
            this.totalCount = _data["totalCount"] !== undefined ? _data["totalCount"] : <any>null;
        }
    }

    static fromJS(data: any, _mappings?: any): PagedResultDto_1OfOfIdentityRoleDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<PagedResultDto_1OfOfIdentityRoleDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null>(data, _mappings, PagedResultDto_1OfOfIdentityRoleDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount !== undefined ? this.totalCount : <any>null;
        return data; 
    }
}

export class PagedResultDto_1OfOfIdentityUserDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null {
    items!: IdentityUserDto[] | null;
    totalCount!: number;

    init(_data?: any, _mappings?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(IdentityUserDto.fromJS(item, _mappings));
            }
            else {
                this.items = <any>null;
            }
            this.totalCount = _data["totalCount"] !== undefined ? _data["totalCount"] : <any>null;
        }
    }

    static fromJS(data: any, _mappings?: any): PagedResultDto_1OfOfIdentityUserDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<PagedResultDto_1OfOfIdentityUserDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null>(data, _mappings, PagedResultDto_1OfOfIdentityUserDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount !== undefined ? this.totalCount : <any>null;
        return data; 
    }
}

export class PagedResultDto_1OfOfTenantDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null {
    items!: TenantDto[] | null;
    totalCount!: number;

    init(_data?: any, _mappings?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(TenantDto.fromJS(item, _mappings));
            }
            else {
                this.items = <any>null;
            }
            this.totalCount = _data["totalCount"] !== undefined ? _data["totalCount"] : <any>null;
        }
    }

    static fromJS(data: any, _mappings?: any): PagedResultDto_1OfOfTenantDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<PagedResultDto_1OfOfTenantDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null>(data, _mappings, PagedResultDto_1OfOfTenantDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount !== undefined ? this.totalCount : <any>null;
        return data; 
    }
}

export class ApplicationAuthConfigurationDto {
    policies!: { [key: string]: boolean; } | null;
    grantedPolicies!: { [key: string]: boolean; } | null;

    init(_data?: any, _mappings?: any) {
        if (_data) {
            if (_data["policies"]) {
                this.policies = {} as any;
                for (let key in _data["policies"]) {
                    if (_data["policies"].hasOwnProperty(key))
                        (<any>this.policies)![key] = _data["policies"][key];
                }
            }
            else {
                this.policies = <any>null;
            }
            if (_data["grantedPolicies"]) {
                this.grantedPolicies = {} as any;
                for (let key in _data["grantedPolicies"]) {
                    if (_data["grantedPolicies"].hasOwnProperty(key))
                        (<any>this.grantedPolicies)![key] = _data["grantedPolicies"][key];
                }
            }
            else {
                this.grantedPolicies = <any>null;
            }
        }
    }

    static fromJS(data: any, _mappings?: any): ApplicationAuthConfigurationDto | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<ApplicationAuthConfigurationDto>(data, _mappings, ApplicationAuthConfigurationDto);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.policies) {
            data["policies"] = {};
            for (let key in this.policies) {
                if (this.policies.hasOwnProperty(key))
                    (<any>data["policies"])[key] = this.policies[key] !== undefined ? this.policies[key] : <any>null;
            }
        }
        if (this.grantedPolicies) {
            data["grantedPolicies"] = {};
            for (let key in this.grantedPolicies) {
                if (this.grantedPolicies.hasOwnProperty(key))
                    (<any>data["grantedPolicies"])[key] = this.grantedPolicies[key] !== undefined ? this.grantedPolicies[key] : <any>null;
            }
        }
        return data; 
    }
}

export class ApplicationConfigurationDto {
    localization!: ApplicationLocalizationConfigurationDto;
    auth!: ApplicationAuthConfigurationDto;
    setting!: ApplicationSettingConfigurationDto;
    currentUser!: CurrentUserDto;
    features!: ApplicationFeatureConfigurationDto;
    multiTenancy!: MultiTenancyInfoDto;
    currentTenant!: CurrentTenantDto;
    timing!: TimingDto;
    clock!: ClockDto;
    objectExtensions!: ObjectExtensionsDto;

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.localization = _data["localization"] ? ApplicationLocalizationConfigurationDto.fromJS(_data["localization"], _mappings) : <any>null;
            this.auth = _data["auth"] ? ApplicationAuthConfigurationDto.fromJS(_data["auth"], _mappings) : <any>null;
            this.setting = _data["setting"] ? ApplicationSettingConfigurationDto.fromJS(_data["setting"], _mappings) : <any>null;
            this.currentUser = _data["currentUser"] ? CurrentUserDto.fromJS(_data["currentUser"], _mappings) : <any>null;
            this.features = _data["features"] ? ApplicationFeatureConfigurationDto.fromJS(_data["features"], _mappings) : <any>null;
            this.multiTenancy = _data["multiTenancy"] ? MultiTenancyInfoDto.fromJS(_data["multiTenancy"], _mappings) : <any>null;
            this.currentTenant = _data["currentTenant"] ? CurrentTenantDto.fromJS(_data["currentTenant"], _mappings) : <any>null;
            this.timing = _data["timing"] ? TimingDto.fromJS(_data["timing"], _mappings) : <any>null;
            this.clock = _data["clock"] ? ClockDto.fromJS(_data["clock"], _mappings) : <any>null;
            this.objectExtensions = _data["objectExtensions"] ? ObjectExtensionsDto.fromJS(_data["objectExtensions"], _mappings) : <any>null;
        }
    }

    static fromJS(data: any, _mappings?: any): ApplicationConfigurationDto | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<ApplicationConfigurationDto>(data, _mappings, ApplicationConfigurationDto);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["localization"] = this.localization ? this.localization.toJSON() : <any>null;
        data["auth"] = this.auth ? this.auth.toJSON() : <any>null;
        data["setting"] = this.setting ? this.setting.toJSON() : <any>null;
        data["currentUser"] = this.currentUser ? this.currentUser.toJSON() : <any>null;
        data["features"] = this.features ? this.features.toJSON() : <any>null;
        data["multiTenancy"] = this.multiTenancy ? this.multiTenancy.toJSON() : <any>null;
        data["currentTenant"] = this.currentTenant ? this.currentTenant.toJSON() : <any>null;
        data["timing"] = this.timing ? this.timing.toJSON() : <any>null;
        data["clock"] = this.clock ? this.clock.toJSON() : <any>null;
        data["objectExtensions"] = this.objectExtensions ? this.objectExtensions.toJSON() : <any>null;
        return data; 
    }
}

export class ApplicationFeatureConfigurationDto {
    values!: { [key: string]: string; } | null;

    init(_data?: any, _mappings?: any) {
        if (_data) {
            if (_data["values"]) {
                this.values = {} as any;
                for (let key in _data["values"]) {
                    if (_data["values"].hasOwnProperty(key))
                        (<any>this.values)![key] = _data["values"][key];
                }
            }
            else {
                this.values = <any>null;
            }
        }
    }

    static fromJS(data: any, _mappings?: any): ApplicationFeatureConfigurationDto | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<ApplicationFeatureConfigurationDto>(data, _mappings, ApplicationFeatureConfigurationDto);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.values) {
            data["values"] = {};
            for (let key in this.values) {
                if (this.values.hasOwnProperty(key))
                    (<any>data["values"])[key] = this.values[key] !== undefined ? this.values[key] : <any>null;
            }
        }
        return data; 
    }
}

export class ApplicationLocalizationConfigurationDto {
    values!: { [key: string]: { [key: string]: string; }; } | null;
    languages!: LanguageInfo[] | null;
    currentCulture!: CurrentCultureDto;
    defaultResourceName!: string | null;
    languagesMap!: { [key: string]: NameValue[]; } | null;
    languageFilesMap!: { [key: string]: NameValue[]; } | null;

    init(_data?: any, _mappings?: any) {
        if (_data) {
            if (_data["values"]) {
                this.values = {} as any;
                for (let key in _data["values"]) {
                    if (_data["values"].hasOwnProperty(key))
                        (<any>this.values)![key] = _data["values"][key] !== undefined ? _data["values"][key] : {};
                }
            }
            else {
                this.values = <any>null;
            }
            if (Array.isArray(_data["languages"])) {
                this.languages = [] as any;
                for (let item of _data["languages"])
                    this.languages!.push(LanguageInfo.fromJS(item, _mappings));
            }
            else {
                this.languages = <any>null;
            }
            this.currentCulture = _data["currentCulture"] ? CurrentCultureDto.fromJS(_data["currentCulture"], _mappings) : <any>null;
            this.defaultResourceName = _data["defaultResourceName"] !== undefined ? _data["defaultResourceName"] : <any>null;
            if (_data["languagesMap"]) {
                this.languagesMap = {} as any;
                for (let key in _data["languagesMap"]) {
                    if (_data["languagesMap"].hasOwnProperty(key))
                        (<any>this.languagesMap)![key] = _data["languagesMap"][key] ? _data["languagesMap"][key].map((i: any) => NameValue.fromJS(i, _mappings)) : [];
                }
            }
            else {
                this.languagesMap = <any>null;
            }
            if (_data["languageFilesMap"]) {
                this.languageFilesMap = {} as any;
                for (let key in _data["languageFilesMap"]) {
                    if (_data["languageFilesMap"].hasOwnProperty(key))
                        (<any>this.languageFilesMap)![key] = _data["languageFilesMap"][key] ? _data["languageFilesMap"][key].map((i: any) => NameValue.fromJS(i, _mappings)) : [];
                }
            }
            else {
                this.languageFilesMap = <any>null;
            }
        }
    }

    static fromJS(data: any, _mappings?: any): ApplicationLocalizationConfigurationDto | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<ApplicationLocalizationConfigurationDto>(data, _mappings, ApplicationLocalizationConfigurationDto);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.values) {
            data["values"] = {};
            for (let key in this.values) {
                if (this.values.hasOwnProperty(key))
                    (<any>data["values"])[key] = this.values[key] !== undefined ? this.values[key] : <any>null;
            }
        }
        if (Array.isArray(this.languages)) {
            data["languages"] = [];
            for (let item of this.languages)
                data["languages"].push(item.toJSON());
        }
        data["currentCulture"] = this.currentCulture ? this.currentCulture.toJSON() : <any>null;
        data["defaultResourceName"] = this.defaultResourceName !== undefined ? this.defaultResourceName : <any>null;
        if (this.languagesMap) {
            data["languagesMap"] = {};
            for (let key in this.languagesMap) {
                if (this.languagesMap.hasOwnProperty(key))
                    (<any>data["languagesMap"])[key] = this.languagesMap[key] !== undefined ? this.languagesMap[key] : <any>null;
            }
        }
        if (this.languageFilesMap) {
            data["languageFilesMap"] = {};
            for (let key in this.languageFilesMap) {
                if (this.languageFilesMap.hasOwnProperty(key))
                    (<any>data["languageFilesMap"])[key] = this.languageFilesMap[key] !== undefined ? this.languageFilesMap[key] : <any>null;
            }
        }
        return data; 
    }
}

export class ApplicationSettingConfigurationDto {
    values!: { [key: string]: string; } | null;

    init(_data?: any, _mappings?: any) {
        if (_data) {
            if (_data["values"]) {
                this.values = {} as any;
                for (let key in _data["values"]) {
                    if (_data["values"].hasOwnProperty(key))
                        (<any>this.values)![key] = _data["values"][key];
                }
            }
            else {
                this.values = <any>null;
            }
        }
    }

    static fromJS(data: any, _mappings?: any): ApplicationSettingConfigurationDto | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<ApplicationSettingConfigurationDto>(data, _mappings, ApplicationSettingConfigurationDto);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.values) {
            data["values"] = {};
            for (let key in this.values) {
                if (this.values.hasOwnProperty(key))
                    (<any>data["values"])[key] = this.values[key] !== undefined ? this.values[key] : <any>null;
            }
        }
        return data; 
    }
}

export class ClockDto {
    kind!: string | null;

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.kind = _data["kind"] !== undefined ? _data["kind"] : <any>null;
        }
    }

    static fromJS(data: any, _mappings?: any): ClockDto | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<ClockDto>(data, _mappings, ClockDto);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["kind"] = this.kind !== undefined ? this.kind : <any>null;
        return data; 
    }
}

export class CurrentCultureDto {
    displayName!: string | null;
    englishName!: string | null;
    threeLetterIsoLanguageName!: string | null;
    twoLetterIsoLanguageName!: string | null;
    isRightToLeft!: boolean;
    cultureName!: string | null;
    name!: string | null;
    nativeName!: string | null;
    dateTimeFormat!: DateTimeFormatDto;

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.displayName = _data["displayName"] !== undefined ? _data["displayName"] : <any>null;
            this.englishName = _data["englishName"] !== undefined ? _data["englishName"] : <any>null;
            this.threeLetterIsoLanguageName = _data["threeLetterIsoLanguageName"] !== undefined ? _data["threeLetterIsoLanguageName"] : <any>null;
            this.twoLetterIsoLanguageName = _data["twoLetterIsoLanguageName"] !== undefined ? _data["twoLetterIsoLanguageName"] : <any>null;
            this.isRightToLeft = _data["isRightToLeft"] !== undefined ? _data["isRightToLeft"] : <any>null;
            this.cultureName = _data["cultureName"] !== undefined ? _data["cultureName"] : <any>null;
            this.name = _data["name"] !== undefined ? _data["name"] : <any>null;
            this.nativeName = _data["nativeName"] !== undefined ? _data["nativeName"] : <any>null;
            this.dateTimeFormat = _data["dateTimeFormat"] ? DateTimeFormatDto.fromJS(_data["dateTimeFormat"], _mappings) : <any>null;
        }
    }

    static fromJS(data: any, _mappings?: any): CurrentCultureDto | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<CurrentCultureDto>(data, _mappings, CurrentCultureDto);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["displayName"] = this.displayName !== undefined ? this.displayName : <any>null;
        data["englishName"] = this.englishName !== undefined ? this.englishName : <any>null;
        data["threeLetterIsoLanguageName"] = this.threeLetterIsoLanguageName !== undefined ? this.threeLetterIsoLanguageName : <any>null;
        data["twoLetterIsoLanguageName"] = this.twoLetterIsoLanguageName !== undefined ? this.twoLetterIsoLanguageName : <any>null;
        data["isRightToLeft"] = this.isRightToLeft !== undefined ? this.isRightToLeft : <any>null;
        data["cultureName"] = this.cultureName !== undefined ? this.cultureName : <any>null;
        data["name"] = this.name !== undefined ? this.name : <any>null;
        data["nativeName"] = this.nativeName !== undefined ? this.nativeName : <any>null;
        data["dateTimeFormat"] = this.dateTimeFormat ? this.dateTimeFormat.toJSON() : <any>null;
        return data; 
    }
}

export class CurrentUserDto {
    isAuthenticated!: boolean;
    id!: string | null;
    tenantId!: string | null;
    userName!: string | null;
    name!: string | null;
    surName!: string | null;
    email!: string | null;
    emailVerified!: boolean;
    phoneNumber!: string | null;
    phoneNumberVerified!: boolean;
    roles!: string[] | null;

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.isAuthenticated = _data["isAuthenticated"] !== undefined ? _data["isAuthenticated"] : <any>null;
            this.id = _data["id"] !== undefined ? _data["id"] : <any>null;
            this.tenantId = _data["tenantId"] !== undefined ? _data["tenantId"] : <any>null;
            this.userName = _data["userName"] !== undefined ? _data["userName"] : <any>null;
            this.name = _data["name"] !== undefined ? _data["name"] : <any>null;
            this.surName = _data["surName"] !== undefined ? _data["surName"] : <any>null;
            this.email = _data["email"] !== undefined ? _data["email"] : <any>null;
            this.emailVerified = _data["emailVerified"] !== undefined ? _data["emailVerified"] : <any>null;
            this.phoneNumber = _data["phoneNumber"] !== undefined ? _data["phoneNumber"] : <any>null;
            this.phoneNumberVerified = _data["phoneNumberVerified"] !== undefined ? _data["phoneNumberVerified"] : <any>null;
            if (Array.isArray(_data["roles"])) {
                this.roles = [] as any;
                for (let item of _data["roles"])
                    this.roles!.push(item);
            }
            else {
                this.roles = <any>null;
            }
        }
    }

    static fromJS(data: any, _mappings?: any): CurrentUserDto | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<CurrentUserDto>(data, _mappings, CurrentUserDto);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isAuthenticated"] = this.isAuthenticated !== undefined ? this.isAuthenticated : <any>null;
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["tenantId"] = this.tenantId !== undefined ? this.tenantId : <any>null;
        data["userName"] = this.userName !== undefined ? this.userName : <any>null;
        data["name"] = this.name !== undefined ? this.name : <any>null;
        data["surName"] = this.surName !== undefined ? this.surName : <any>null;
        data["email"] = this.email !== undefined ? this.email : <any>null;
        data["emailVerified"] = this.emailVerified !== undefined ? this.emailVerified : <any>null;
        data["phoneNumber"] = this.phoneNumber !== undefined ? this.phoneNumber : <any>null;
        data["phoneNumberVerified"] = this.phoneNumberVerified !== undefined ? this.phoneNumberVerified : <any>null;
        if (Array.isArray(this.roles)) {
            data["roles"] = [];
            for (let item of this.roles)
                data["roles"].push(item);
        }
        return data; 
    }
}

export class DateTimeFormatDto {
    calendarAlgorithmType!: string | null;
    dateTimeFormatLong!: string | null;
    shortDatePattern!: string | null;
    fullDateTimePattern!: string | null;
    dateSeparator!: string | null;
    shortTimePattern!: string | null;
    longTimePattern!: string | null;

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.calendarAlgorithmType = _data["calendarAlgorithmType"] !== undefined ? _data["calendarAlgorithmType"] : <any>null;
            this.dateTimeFormatLong = _data["dateTimeFormatLong"] !== undefined ? _data["dateTimeFormatLong"] : <any>null;
            this.shortDatePattern = _data["shortDatePattern"] !== undefined ? _data["shortDatePattern"] : <any>null;
            this.fullDateTimePattern = _data["fullDateTimePattern"] !== undefined ? _data["fullDateTimePattern"] : <any>null;
            this.dateSeparator = _data["dateSeparator"] !== undefined ? _data["dateSeparator"] : <any>null;
            this.shortTimePattern = _data["shortTimePattern"] !== undefined ? _data["shortTimePattern"] : <any>null;
            this.longTimePattern = _data["longTimePattern"] !== undefined ? _data["longTimePattern"] : <any>null;
        }
    }

    static fromJS(data: any, _mappings?: any): DateTimeFormatDto | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<DateTimeFormatDto>(data, _mappings, DateTimeFormatDto);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["calendarAlgorithmType"] = this.calendarAlgorithmType !== undefined ? this.calendarAlgorithmType : <any>null;
        data["dateTimeFormatLong"] = this.dateTimeFormatLong !== undefined ? this.dateTimeFormatLong : <any>null;
        data["shortDatePattern"] = this.shortDatePattern !== undefined ? this.shortDatePattern : <any>null;
        data["fullDateTimePattern"] = this.fullDateTimePattern !== undefined ? this.fullDateTimePattern : <any>null;
        data["dateSeparator"] = this.dateSeparator !== undefined ? this.dateSeparator : <any>null;
        data["shortTimePattern"] = this.shortTimePattern !== undefined ? this.shortTimePattern : <any>null;
        data["longTimePattern"] = this.longTimePattern !== undefined ? this.longTimePattern : <any>null;
        return data; 
    }
}

export class IanaTimeZone {
    timeZoneName!: string | null;

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.timeZoneName = _data["timeZoneName"] !== undefined ? _data["timeZoneName"] : <any>null;
        }
    }

    static fromJS(data: any, _mappings?: any): IanaTimeZone | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<IanaTimeZone>(data, _mappings, IanaTimeZone);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["timeZoneName"] = this.timeZoneName !== undefined ? this.timeZoneName : <any>null;
        return data; 
    }
}

export class EntityExtensionDto {
    properties!: { [key: string]: ExtensionPropertyDto; } | null;
    configuration!: { [key: string]: any; } | null;

    init(_data?: any, _mappings?: any) {
        if (_data) {
            if (_data["properties"]) {
                this.properties = {} as any;
                for (let key in _data["properties"]) {
                    if (_data["properties"].hasOwnProperty(key))
                        (<any>this.properties)![key] = _data["properties"][key] ? ExtensionPropertyDto.fromJS(_data["properties"][key], _mappings) : new ExtensionPropertyDto();
                }
            }
            else {
                this.properties = <any>null;
            }
            if (_data["configuration"]) {
                this.configuration = {} as any;
                for (let key in _data["configuration"]) {
                    if (_data["configuration"].hasOwnProperty(key))
                        (<any>this.configuration)![key] = _data["configuration"][key];
                }
            }
            else {
                this.configuration = <any>null;
            }
        }
    }

    static fromJS(data: any, _mappings?: any): EntityExtensionDto | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<EntityExtensionDto>(data, _mappings, EntityExtensionDto);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.properties) {
            data["properties"] = {};
            for (let key in this.properties) {
                if (this.properties.hasOwnProperty(key))
                    (<any>data["properties"])[key] = this.properties[key] ? this.properties[key].toJSON() : <any>null;
            }
        }
        if (this.configuration) {
            data["configuration"] = {};
            for (let key in this.configuration) {
                if (this.configuration.hasOwnProperty(key))
                    (<any>data["configuration"])[key] = this.configuration[key] !== undefined ? this.configuration[key] : <any>null;
            }
        }
        return data; 
    }
}

export class ExtensionEnumDto {
    fields!: ExtensionEnumFieldDto[] | null;
    localizationResource!: string | null;

    init(_data?: any, _mappings?: any) {
        if (_data) {
            if (Array.isArray(_data["fields"])) {
                this.fields = [] as any;
                for (let item of _data["fields"])
                    this.fields!.push(ExtensionEnumFieldDto.fromJS(item, _mappings));
            }
            else {
                this.fields = <any>null;
            }
            this.localizationResource = _data["localizationResource"] !== undefined ? _data["localizationResource"] : <any>null;
        }
    }

    static fromJS(data: any, _mappings?: any): ExtensionEnumDto | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<ExtensionEnumDto>(data, _mappings, ExtensionEnumDto);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.fields)) {
            data["fields"] = [];
            for (let item of this.fields)
                data["fields"].push(item.toJSON());
        }
        data["localizationResource"] = this.localizationResource !== undefined ? this.localizationResource : <any>null;
        return data; 
    }
}

export class ExtensionEnumFieldDto {
    name!: string | null;
    value!: any | null;

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.name = _data["name"] !== undefined ? _data["name"] : <any>null;
            this.value = _data["value"] !== undefined ? _data["value"] : <any>null;
        }
    }

    static fromJS(data: any, _mappings?: any): ExtensionEnumFieldDto | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<ExtensionEnumFieldDto>(data, _mappings, ExtensionEnumFieldDto);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name !== undefined ? this.name : <any>null;
        data["value"] = this.value !== undefined ? this.value : <any>null;
        return data; 
    }
}

export class ExtensionPropertyApiCreateDto {
    isAvailable!: boolean;

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.isAvailable = _data["isAvailable"] !== undefined ? _data["isAvailable"] : <any>null;
        }
    }

    static fromJS(data: any, _mappings?: any): ExtensionPropertyApiCreateDto | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<ExtensionPropertyApiCreateDto>(data, _mappings, ExtensionPropertyApiCreateDto);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isAvailable"] = this.isAvailable !== undefined ? this.isAvailable : <any>null;
        return data; 
    }
}

export class ExtensionPropertyApiDto {
    onGet!: ExtensionPropertyApiGetDto;
    onCreate!: ExtensionPropertyApiCreateDto;
    onUpdate!: ExtensionPropertyApiUpdateDto;

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.onGet = _data["onGet"] ? ExtensionPropertyApiGetDto.fromJS(_data["onGet"], _mappings) : <any>null;
            this.onCreate = _data["onCreate"] ? ExtensionPropertyApiCreateDto.fromJS(_data["onCreate"], _mappings) : <any>null;
            this.onUpdate = _data["onUpdate"] ? ExtensionPropertyApiUpdateDto.fromJS(_data["onUpdate"], _mappings) : <any>null;
        }
    }

    static fromJS(data: any, _mappings?: any): ExtensionPropertyApiDto | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<ExtensionPropertyApiDto>(data, _mappings, ExtensionPropertyApiDto);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["onGet"] = this.onGet ? this.onGet.toJSON() : <any>null;
        data["onCreate"] = this.onCreate ? this.onCreate.toJSON() : <any>null;
        data["onUpdate"] = this.onUpdate ? this.onUpdate.toJSON() : <any>null;
        return data; 
    }
}

export class ExtensionPropertyApiGetDto {
    isAvailable!: boolean;

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.isAvailable = _data["isAvailable"] !== undefined ? _data["isAvailable"] : <any>null;
        }
    }

    static fromJS(data: any, _mappings?: any): ExtensionPropertyApiGetDto | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<ExtensionPropertyApiGetDto>(data, _mappings, ExtensionPropertyApiGetDto);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isAvailable"] = this.isAvailable !== undefined ? this.isAvailable : <any>null;
        return data; 
    }
}

export class ExtensionPropertyApiUpdateDto {
    isAvailable!: boolean;

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.isAvailable = _data["isAvailable"] !== undefined ? _data["isAvailable"] : <any>null;
        }
    }

    static fromJS(data: any, _mappings?: any): ExtensionPropertyApiUpdateDto | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<ExtensionPropertyApiUpdateDto>(data, _mappings, ExtensionPropertyApiUpdateDto);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isAvailable"] = this.isAvailable !== undefined ? this.isAvailable : <any>null;
        return data; 
    }
}

export class ExtensionPropertyAttributeDto {
    typeSimple!: string | null;
    config!: { [key: string]: any; } | null;

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.typeSimple = _data["typeSimple"] !== undefined ? _data["typeSimple"] : <any>null;
            if (_data["config"]) {
                this.config = {} as any;
                for (let key in _data["config"]) {
                    if (_data["config"].hasOwnProperty(key))
                        (<any>this.config)![key] = _data["config"][key];
                }
            }
            else {
                this.config = <any>null;
            }
        }
    }

    static fromJS(data: any, _mappings?: any): ExtensionPropertyAttributeDto | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<ExtensionPropertyAttributeDto>(data, _mappings, ExtensionPropertyAttributeDto);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["typeSimple"] = this.typeSimple !== undefined ? this.typeSimple : <any>null;
        if (this.config) {
            data["config"] = {};
            for (let key in this.config) {
                if (this.config.hasOwnProperty(key))
                    (<any>data["config"])[key] = this.config[key] !== undefined ? this.config[key] : <any>null;
            }
        }
        return data; 
    }
}

export class ExtensionPropertyDto {
    type!: string | null;
    typeSimple!: string | null;
    displayName!: LocalizableStringDto;
    api!: ExtensionPropertyApiDto;
    ui!: ExtensionPropertyUiDto;
    attributes!: ExtensionPropertyAttributeDto[] | null;
    configuration!: { [key: string]: any; } | null;
    defaultValue!: any | null;

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.type = _data["type"] !== undefined ? _data["type"] : <any>null;
            this.typeSimple = _data["typeSimple"] !== undefined ? _data["typeSimple"] : <any>null;
            this.displayName = _data["displayName"] ? LocalizableStringDto.fromJS(_data["displayName"], _mappings) : <any>null;
            this.api = _data["api"] ? ExtensionPropertyApiDto.fromJS(_data["api"], _mappings) : <any>null;
            this.ui = _data["ui"] ? ExtensionPropertyUiDto.fromJS(_data["ui"], _mappings) : <any>null;
            if (Array.isArray(_data["attributes"])) {
                this.attributes = [] as any;
                for (let item of _data["attributes"])
                    this.attributes!.push(ExtensionPropertyAttributeDto.fromJS(item, _mappings));
            }
            else {
                this.attributes = <any>null;
            }
            if (_data["configuration"]) {
                this.configuration = {} as any;
                for (let key in _data["configuration"]) {
                    if (_data["configuration"].hasOwnProperty(key))
                        (<any>this.configuration)![key] = _data["configuration"][key];
                }
            }
            else {
                this.configuration = <any>null;
            }
            this.defaultValue = _data["defaultValue"] !== undefined ? _data["defaultValue"] : <any>null;
        }
    }

    static fromJS(data: any, _mappings?: any): ExtensionPropertyDto | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<ExtensionPropertyDto>(data, _mappings, ExtensionPropertyDto);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["type"] = this.type !== undefined ? this.type : <any>null;
        data["typeSimple"] = this.typeSimple !== undefined ? this.typeSimple : <any>null;
        data["displayName"] = this.displayName ? this.displayName.toJSON() : <any>null;
        data["api"] = this.api ? this.api.toJSON() : <any>null;
        data["ui"] = this.ui ? this.ui.toJSON() : <any>null;
        if (Array.isArray(this.attributes)) {
            data["attributes"] = [];
            for (let item of this.attributes)
                data["attributes"].push(item.toJSON());
        }
        if (this.configuration) {
            data["configuration"] = {};
            for (let key in this.configuration) {
                if (this.configuration.hasOwnProperty(key))
                    (<any>data["configuration"])[key] = this.configuration[key] !== undefined ? this.configuration[key] : <any>null;
            }
        }
        data["defaultValue"] = this.defaultValue !== undefined ? this.defaultValue : <any>null;
        return data; 
    }
}

export class ExtensionPropertyUiDto {
    onTable!: ExtensionPropertyUiTableDto;
    onCreateForm!: ExtensionPropertyUiFormDto;
    onEditForm!: ExtensionPropertyUiFormDto;
    lookup!: ExtensionPropertyUiLookupDto;

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.onTable = _data["onTable"] ? ExtensionPropertyUiTableDto.fromJS(_data["onTable"], _mappings) : <any>null;
            this.onCreateForm = _data["onCreateForm"] ? ExtensionPropertyUiFormDto.fromJS(_data["onCreateForm"], _mappings) : <any>null;
            this.onEditForm = _data["onEditForm"] ? ExtensionPropertyUiFormDto.fromJS(_data["onEditForm"], _mappings) : <any>null;
            this.lookup = _data["lookup"] ? ExtensionPropertyUiLookupDto.fromJS(_data["lookup"], _mappings) : <any>null;
        }
    }

    static fromJS(data: any, _mappings?: any): ExtensionPropertyUiDto | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<ExtensionPropertyUiDto>(data, _mappings, ExtensionPropertyUiDto);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["onTable"] = this.onTable ? this.onTable.toJSON() : <any>null;
        data["onCreateForm"] = this.onCreateForm ? this.onCreateForm.toJSON() : <any>null;
        data["onEditForm"] = this.onEditForm ? this.onEditForm.toJSON() : <any>null;
        data["lookup"] = this.lookup ? this.lookup.toJSON() : <any>null;
        return data; 
    }
}

export class ExtensionPropertyUiFormDto {
    isVisible!: boolean;

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.isVisible = _data["isVisible"] !== undefined ? _data["isVisible"] : <any>null;
        }
    }

    static fromJS(data: any, _mappings?: any): ExtensionPropertyUiFormDto | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<ExtensionPropertyUiFormDto>(data, _mappings, ExtensionPropertyUiFormDto);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isVisible"] = this.isVisible !== undefined ? this.isVisible : <any>null;
        return data; 
    }
}

export class ExtensionPropertyUiLookupDto {
    url!: string | null;
    resultListPropertyName!: string | null;
    displayPropertyName!: string | null;
    valuePropertyName!: string | null;
    filterParamName!: string | null;

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.url = _data["url"] !== undefined ? _data["url"] : <any>null;
            this.resultListPropertyName = _data["resultListPropertyName"] !== undefined ? _data["resultListPropertyName"] : <any>null;
            this.displayPropertyName = _data["displayPropertyName"] !== undefined ? _data["displayPropertyName"] : <any>null;
            this.valuePropertyName = _data["valuePropertyName"] !== undefined ? _data["valuePropertyName"] : <any>null;
            this.filterParamName = _data["filterParamName"] !== undefined ? _data["filterParamName"] : <any>null;
        }
    }

    static fromJS(data: any, _mappings?: any): ExtensionPropertyUiLookupDto | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<ExtensionPropertyUiLookupDto>(data, _mappings, ExtensionPropertyUiLookupDto);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["url"] = this.url !== undefined ? this.url : <any>null;
        data["resultListPropertyName"] = this.resultListPropertyName !== undefined ? this.resultListPropertyName : <any>null;
        data["displayPropertyName"] = this.displayPropertyName !== undefined ? this.displayPropertyName : <any>null;
        data["valuePropertyName"] = this.valuePropertyName !== undefined ? this.valuePropertyName : <any>null;
        data["filterParamName"] = this.filterParamName !== undefined ? this.filterParamName : <any>null;
        return data; 
    }
}

export class ExtensionPropertyUiTableDto {
    isVisible!: boolean;

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.isVisible = _data["isVisible"] !== undefined ? _data["isVisible"] : <any>null;
        }
    }

    static fromJS(data: any, _mappings?: any): ExtensionPropertyUiTableDto | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<ExtensionPropertyUiTableDto>(data, _mappings, ExtensionPropertyUiTableDto);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isVisible"] = this.isVisible !== undefined ? this.isVisible : <any>null;
        return data; 
    }
}

export class LocalizableStringDto {
    readonly name!: string | null;
    resource!: string | null;

    init(_data?: any, _mappings?: any) {
        if (_data) {
            (<any>this).name = _data["name"] !== undefined ? _data["name"] : <any>null;
            this.resource = _data["resource"] !== undefined ? _data["resource"] : <any>null;
        }
    }

    static fromJS(data: any, _mappings?: any): LocalizableStringDto | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<LocalizableStringDto>(data, _mappings, LocalizableStringDto);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name !== undefined ? this.name : <any>null;
        data["resource"] = this.resource !== undefined ? this.resource : <any>null;
        return data; 
    }
}

export class ModuleExtensionDto {
    entities!: { [key: string]: EntityExtensionDto; } | null;
    configuration!: { [key: string]: any; } | null;

    init(_data?: any, _mappings?: any) {
        if (_data) {
            if (_data["entities"]) {
                this.entities = {} as any;
                for (let key in _data["entities"]) {
                    if (_data["entities"].hasOwnProperty(key))
                        (<any>this.entities)![key] = _data["entities"][key] ? EntityExtensionDto.fromJS(_data["entities"][key], _mappings) : new EntityExtensionDto();
                }
            }
            else {
                this.entities = <any>null;
            }
            if (_data["configuration"]) {
                this.configuration = {} as any;
                for (let key in _data["configuration"]) {
                    if (_data["configuration"].hasOwnProperty(key))
                        (<any>this.configuration)![key] = _data["configuration"][key];
                }
            }
            else {
                this.configuration = <any>null;
            }
        }
    }

    static fromJS(data: any, _mappings?: any): ModuleExtensionDto | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<ModuleExtensionDto>(data, _mappings, ModuleExtensionDto);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.entities) {
            data["entities"] = {};
            for (let key in this.entities) {
                if (this.entities.hasOwnProperty(key))
                    (<any>data["entities"])[key] = this.entities[key] ? this.entities[key].toJSON() : <any>null;
            }
        }
        if (this.configuration) {
            data["configuration"] = {};
            for (let key in this.configuration) {
                if (this.configuration.hasOwnProperty(key))
                    (<any>data["configuration"])[key] = this.configuration[key] !== undefined ? this.configuration[key] : <any>null;
            }
        }
        return data; 
    }
}

export class ObjectExtensionsDto {
    modules!: { [key: string]: ModuleExtensionDto; } | null;
    enums!: { [key: string]: ExtensionEnumDto; } | null;

    init(_data?: any, _mappings?: any) {
        if (_data) {
            if (_data["modules"]) {
                this.modules = {} as any;
                for (let key in _data["modules"]) {
                    if (_data["modules"].hasOwnProperty(key))
                        (<any>this.modules)![key] = _data["modules"][key] ? ModuleExtensionDto.fromJS(_data["modules"][key], _mappings) : new ModuleExtensionDto();
                }
            }
            else {
                this.modules = <any>null;
            }
            if (_data["enums"]) {
                this.enums = {} as any;
                for (let key in _data["enums"]) {
                    if (_data["enums"].hasOwnProperty(key))
                        (<any>this.enums)![key] = _data["enums"][key] ? ExtensionEnumDto.fromJS(_data["enums"][key], _mappings) : new ExtensionEnumDto();
                }
            }
            else {
                this.enums = <any>null;
            }
        }
    }

    static fromJS(data: any, _mappings?: any): ObjectExtensionsDto | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<ObjectExtensionsDto>(data, _mappings, ObjectExtensionsDto);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.modules) {
            data["modules"] = {};
            for (let key in this.modules) {
                if (this.modules.hasOwnProperty(key))
                    (<any>data["modules"])[key] = this.modules[key] ? this.modules[key].toJSON() : <any>null;
            }
        }
        if (this.enums) {
            data["enums"] = {};
            for (let key in this.enums) {
                if (this.enums.hasOwnProperty(key))
                    (<any>data["enums"])[key] = this.enums[key] ? this.enums[key].toJSON() : <any>null;
            }
        }
        return data; 
    }
}

export class TimeZone {
    iana!: IanaTimeZone;
    windows!: WindowsTimeZone;

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.iana = _data["iana"] ? IanaTimeZone.fromJS(_data["iana"], _mappings) : <any>null;
            this.windows = _data["windows"] ? WindowsTimeZone.fromJS(_data["windows"], _mappings) : <any>null;
        }
    }

    static fromJS(data: any, _mappings?: any): TimeZone | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<TimeZone>(data, _mappings, TimeZone);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["iana"] = this.iana ? this.iana.toJSON() : <any>null;
        data["windows"] = this.windows ? this.windows.toJSON() : <any>null;
        return data; 
    }
}

export class TimingDto {
    timeZone!: TimeZone;

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.timeZone = _data["timeZone"] ? TimeZone.fromJS(_data["timeZone"], _mappings) : <any>null;
        }
    }

    static fromJS(data: any, _mappings?: any): TimingDto | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<TimingDto>(data, _mappings, TimingDto);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["timeZone"] = this.timeZone ? this.timeZone.toJSON() : <any>null;
        return data; 
    }
}

export class WindowsTimeZone {
    timeZoneId!: string | null;

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.timeZoneId = _data["timeZoneId"] !== undefined ? _data["timeZoneId"] : <any>null;
        }
    }

    static fromJS(data: any, _mappings?: any): WindowsTimeZone | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<WindowsTimeZone>(data, _mappings, WindowsTimeZone);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["timeZoneId"] = this.timeZoneId !== undefined ? this.timeZoneId : <any>null;
        return data; 
    }
}

export class CurrentTenantDto {
    id!: string | null;
    name!: string | null;
    isAvailable!: boolean;

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.id = _data["id"] !== undefined ? _data["id"] : <any>null;
            this.name = _data["name"] !== undefined ? _data["name"] : <any>null;
            this.isAvailable = _data["isAvailable"] !== undefined ? _data["isAvailable"] : <any>null;
        }
    }

    static fromJS(data: any, _mappings?: any): CurrentTenantDto | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<CurrentTenantDto>(data, _mappings, CurrentTenantDto);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["name"] = this.name !== undefined ? this.name : <any>null;
        data["isAvailable"] = this.isAvailable !== undefined ? this.isAvailable : <any>null;
        return data; 
    }
}

export class FindTenantResultDto {
    success!: boolean;
    tenantId!: string | null;
    name!: string | null;

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.success = _data["success"] !== undefined ? _data["success"] : <any>null;
            this.tenantId = _data["tenantId"] !== undefined ? _data["tenantId"] : <any>null;
            this.name = _data["name"] !== undefined ? _data["name"] : <any>null;
        }
    }

    static fromJS(data: any, _mappings?: any): FindTenantResultDto | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<FindTenantResultDto>(data, _mappings, FindTenantResultDto);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["success"] = this.success !== undefined ? this.success : <any>null;
        data["tenantId"] = this.tenantId !== undefined ? this.tenantId : <any>null;
        data["name"] = this.name !== undefined ? this.name : <any>null;
        return data; 
    }
}

export class MultiTenancyInfoDto {
    isEnabled!: boolean;

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.isEnabled = _data["isEnabled"] !== undefined ? _data["isEnabled"] : <any>null;
        }
    }

    static fromJS(data: any, _mappings?: any): MultiTenancyInfoDto | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<MultiTenancyInfoDto>(data, _mappings, MultiTenancyInfoDto);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isEnabled"] = this.isEnabled !== undefined ? this.isEnabled : <any>null;
        return data; 
    }
}

export class FeatureDto {
    name!: string | null;
    displayName!: string | null;
    value!: string | null;
    provider!: FeatureProviderDto;
    description!: string | null;
    valueType!: IStringValueType;
    depth!: number;
    parentName!: string | null;

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.name = _data["name"] !== undefined ? _data["name"] : <any>null;
            this.displayName = _data["displayName"] !== undefined ? _data["displayName"] : <any>null;
            this.value = _data["value"] !== undefined ? _data["value"] : <any>null;
            this.provider = _data["provider"] ? FeatureProviderDto.fromJS(_data["provider"], _mappings) : <any>null;
            this.description = _data["description"] !== undefined ? _data["description"] : <any>null;
            this.valueType = _data["valueType"] ? IStringValueType.fromJS(_data["valueType"], _mappings) : <any>null;
            this.depth = _data["depth"] !== undefined ? _data["depth"] : <any>null;
            this.parentName = _data["parentName"] !== undefined ? _data["parentName"] : <any>null;
        }
    }

    static fromJS(data: any, _mappings?: any): FeatureDto | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<FeatureDto>(data, _mappings, FeatureDto);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name !== undefined ? this.name : <any>null;
        data["displayName"] = this.displayName !== undefined ? this.displayName : <any>null;
        data["value"] = this.value !== undefined ? this.value : <any>null;
        data["provider"] = this.provider ? this.provider.toJSON() : <any>null;
        data["description"] = this.description !== undefined ? this.description : <any>null;
        data["valueType"] = this.valueType ? this.valueType.toJSON() : <any>null;
        data["depth"] = this.depth !== undefined ? this.depth : <any>null;
        data["parentName"] = this.parentName !== undefined ? this.parentName : <any>null;
        return data; 
    }
}

export class FeatureGroupDto {
    name!: string | null;
    displayName!: string | null;
    features!: FeatureDto[] | null;

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.name = _data["name"] !== undefined ? _data["name"] : <any>null;
            this.displayName = _data["displayName"] !== undefined ? _data["displayName"] : <any>null;
            if (Array.isArray(_data["features"])) {
                this.features = [] as any;
                for (let item of _data["features"])
                    this.features!.push(FeatureDto.fromJS(item, _mappings));
            }
            else {
                this.features = <any>null;
            }
        }
    }

    static fromJS(data: any, _mappings?: any): FeatureGroupDto | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<FeatureGroupDto>(data, _mappings, FeatureGroupDto);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name !== undefined ? this.name : <any>null;
        data["displayName"] = this.displayName !== undefined ? this.displayName : <any>null;
        if (Array.isArray(this.features)) {
            data["features"] = [];
            for (let item of this.features)
                data["features"].push(item.toJSON());
        }
        return data; 
    }
}

export class FeatureProviderDto {
    name!: string | null;
    key!: string | null;

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.name = _data["name"] !== undefined ? _data["name"] : <any>null;
            this.key = _data["key"] !== undefined ? _data["key"] : <any>null;
        }
    }

    static fromJS(data: any, _mappings?: any): FeatureProviderDto | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<FeatureProviderDto>(data, _mappings, FeatureProviderDto);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name !== undefined ? this.name : <any>null;
        data["key"] = this.key !== undefined ? this.key : <any>null;
        return data; 
    }
}

export class GetFeatureListResultDto {
    groups!: FeatureGroupDto[] | null;

    init(_data?: any, _mappings?: any) {
        if (_data) {
            if (Array.isArray(_data["groups"])) {
                this.groups = [] as any;
                for (let item of _data["groups"])
                    this.groups!.push(FeatureGroupDto.fromJS(item, _mappings));
            }
            else {
                this.groups = <any>null;
            }
        }
    }

    static fromJS(data: any, _mappings?: any): GetFeatureListResultDto | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<GetFeatureListResultDto>(data, _mappings, GetFeatureListResultDto);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.groups)) {
            data["groups"] = [];
            for (let item of this.groups)
                data["groups"].push(item.toJSON());
        }
        return data; 
    }
}

export class UpdateFeatureDto {
    name!: string | null;
    value!: string | null;

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.name = _data["name"] !== undefined ? _data["name"] : <any>null;
            this.value = _data["value"] !== undefined ? _data["value"] : <any>null;
        }
    }

    static fromJS(data: any, _mappings?: any): UpdateFeatureDto | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<UpdateFeatureDto>(data, _mappings, UpdateFeatureDto);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name !== undefined ? this.name : <any>null;
        data["value"] = this.value !== undefined ? this.value : <any>null;
        return data; 
    }
}

export class UpdateFeaturesDto {
    features!: UpdateFeatureDto[] | null;

    init(_data?: any, _mappings?: any) {
        if (_data) {
            if (Array.isArray(_data["features"])) {
                this.features = [] as any;
                for (let item of _data["features"])
                    this.features!.push(UpdateFeatureDto.fromJS(item, _mappings));
            }
            else {
                this.features = <any>null;
            }
        }
    }

    static fromJS(data: any, _mappings?: any): UpdateFeaturesDto | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<UpdateFeaturesDto>(data, _mappings, UpdateFeaturesDto);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.features)) {
            data["features"] = [];
            for (let item of this.features)
                data["features"].push(item.toJSON());
        }
        return data; 
    }
}

export class ActionApiDescriptionModel {
    uniqueName!: string | null;
    name!: string | null;
    httpMethod!: string | null;
    url!: string | null;
    supportedVersions!: string[] | null;
    parametersOnMethod!: MethodParameterApiDescriptionModel[] | null;
    parameters!: ParameterApiDescriptionModel[] | null;
    returnValue!: ReturnValueApiDescriptionModel;

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.uniqueName = _data["uniqueName"] !== undefined ? _data["uniqueName"] : <any>null;
            this.name = _data["name"] !== undefined ? _data["name"] : <any>null;
            this.httpMethod = _data["httpMethod"] !== undefined ? _data["httpMethod"] : <any>null;
            this.url = _data["url"] !== undefined ? _data["url"] : <any>null;
            if (Array.isArray(_data["supportedVersions"])) {
                this.supportedVersions = [] as any;
                for (let item of _data["supportedVersions"])
                    this.supportedVersions!.push(item);
            }
            else {
                this.supportedVersions = <any>null;
            }
            if (Array.isArray(_data["parametersOnMethod"])) {
                this.parametersOnMethod = [] as any;
                for (let item of _data["parametersOnMethod"])
                    this.parametersOnMethod!.push(MethodParameterApiDescriptionModel.fromJS(item, _mappings));
            }
            else {
                this.parametersOnMethod = <any>null;
            }
            if (Array.isArray(_data["parameters"])) {
                this.parameters = [] as any;
                for (let item of _data["parameters"])
                    this.parameters!.push(ParameterApiDescriptionModel.fromJS(item, _mappings));
            }
            else {
                this.parameters = <any>null;
            }
            this.returnValue = _data["returnValue"] ? ReturnValueApiDescriptionModel.fromJS(_data["returnValue"], _mappings) : <any>null;
        }
    }

    static fromJS(data: any, _mappings?: any): ActionApiDescriptionModel | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<ActionApiDescriptionModel>(data, _mappings, ActionApiDescriptionModel);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["uniqueName"] = this.uniqueName !== undefined ? this.uniqueName : <any>null;
        data["name"] = this.name !== undefined ? this.name : <any>null;
        data["httpMethod"] = this.httpMethod !== undefined ? this.httpMethod : <any>null;
        data["url"] = this.url !== undefined ? this.url : <any>null;
        if (Array.isArray(this.supportedVersions)) {
            data["supportedVersions"] = [];
            for (let item of this.supportedVersions)
                data["supportedVersions"].push(item);
        }
        if (Array.isArray(this.parametersOnMethod)) {
            data["parametersOnMethod"] = [];
            for (let item of this.parametersOnMethod)
                data["parametersOnMethod"].push(item.toJSON());
        }
        if (Array.isArray(this.parameters)) {
            data["parameters"] = [];
            for (let item of this.parameters)
                data["parameters"].push(item.toJSON());
        }
        data["returnValue"] = this.returnValue ? this.returnValue.toJSON() : <any>null;
        return data; 
    }
}

export class ApplicationApiDescriptionModel {
    modules!: { [key: string]: ModuleApiDescriptionModel; } | null;
    types!: { [key: string]: TypeApiDescriptionModel; } | null;

    init(_data?: any, _mappings?: any) {
        if (_data) {
            if (_data["modules"]) {
                this.modules = {} as any;
                for (let key in _data["modules"]) {
                    if (_data["modules"].hasOwnProperty(key))
                        (<any>this.modules)![key] = _data["modules"][key] ? ModuleApiDescriptionModel.fromJS(_data["modules"][key], _mappings) : new ModuleApiDescriptionModel();
                }
            }
            else {
                this.modules = <any>null;
            }
            if (_data["types"]) {
                this.types = {} as any;
                for (let key in _data["types"]) {
                    if (_data["types"].hasOwnProperty(key))
                        (<any>this.types)![key] = _data["types"][key] ? TypeApiDescriptionModel.fromJS(_data["types"][key], _mappings) : new TypeApiDescriptionModel();
                }
            }
            else {
                this.types = <any>null;
            }
        }
    }

    static fromJS(data: any, _mappings?: any): ApplicationApiDescriptionModel | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<ApplicationApiDescriptionModel>(data, _mappings, ApplicationApiDescriptionModel);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.modules) {
            data["modules"] = {};
            for (let key in this.modules) {
                if (this.modules.hasOwnProperty(key))
                    (<any>data["modules"])[key] = this.modules[key] ? this.modules[key].toJSON() : <any>null;
            }
        }
        if (this.types) {
            data["types"] = {};
            for (let key in this.types) {
                if (this.types.hasOwnProperty(key))
                    (<any>data["types"])[key] = this.types[key] ? this.types[key].toJSON() : <any>null;
            }
        }
        return data; 
    }
}

export class ControllerApiDescriptionModel {
    controllerName!: string | null;
    type!: string | null;
    interfaces!: ControllerInterfaceApiDescriptionModel[] | null;
    actions!: { [key: string]: ActionApiDescriptionModel; } | null;

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.controllerName = _data["controllerName"] !== undefined ? _data["controllerName"] : <any>null;
            this.type = _data["type"] !== undefined ? _data["type"] : <any>null;
            if (Array.isArray(_data["interfaces"])) {
                this.interfaces = [] as any;
                for (let item of _data["interfaces"])
                    this.interfaces!.push(ControllerInterfaceApiDescriptionModel.fromJS(item, _mappings));
            }
            else {
                this.interfaces = <any>null;
            }
            if (_data["actions"]) {
                this.actions = {} as any;
                for (let key in _data["actions"]) {
                    if (_data["actions"].hasOwnProperty(key))
                        (<any>this.actions)![key] = _data["actions"][key] ? ActionApiDescriptionModel.fromJS(_data["actions"][key], _mappings) : new ActionApiDescriptionModel();
                }
            }
            else {
                this.actions = <any>null;
            }
        }
    }

    static fromJS(data: any, _mappings?: any): ControllerApiDescriptionModel | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<ControllerApiDescriptionModel>(data, _mappings, ControllerApiDescriptionModel);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["controllerName"] = this.controllerName !== undefined ? this.controllerName : <any>null;
        data["type"] = this.type !== undefined ? this.type : <any>null;
        if (Array.isArray(this.interfaces)) {
            data["interfaces"] = [];
            for (let item of this.interfaces)
                data["interfaces"].push(item.toJSON());
        }
        if (this.actions) {
            data["actions"] = {};
            for (let key in this.actions) {
                if (this.actions.hasOwnProperty(key))
                    (<any>data["actions"])[key] = this.actions[key] ? this.actions[key].toJSON() : <any>null;
            }
        }
        return data; 
    }
}

export class ControllerInterfaceApiDescriptionModel {
    type!: string | null;

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.type = _data["type"] !== undefined ? _data["type"] : <any>null;
        }
    }

    static fromJS(data: any, _mappings?: any): ControllerInterfaceApiDescriptionModel | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<ControllerInterfaceApiDescriptionModel>(data, _mappings, ControllerInterfaceApiDescriptionModel);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["type"] = this.type !== undefined ? this.type : <any>null;
        return data; 
    }
}

export class MethodParameterApiDescriptionModel {
    name!: string | null;
    typeAsString!: string | null;
    type!: string | null;
    typeSimple!: string | null;
    isOptional!: boolean;
    defaultValue!: any | null;

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.name = _data["name"] !== undefined ? _data["name"] : <any>null;
            this.typeAsString = _data["typeAsString"] !== undefined ? _data["typeAsString"] : <any>null;
            this.type = _data["type"] !== undefined ? _data["type"] : <any>null;
            this.typeSimple = _data["typeSimple"] !== undefined ? _data["typeSimple"] : <any>null;
            this.isOptional = _data["isOptional"] !== undefined ? _data["isOptional"] : <any>null;
            this.defaultValue = _data["defaultValue"] !== undefined ? _data["defaultValue"] : <any>null;
        }
    }

    static fromJS(data: any, _mappings?: any): MethodParameterApiDescriptionModel | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<MethodParameterApiDescriptionModel>(data, _mappings, MethodParameterApiDescriptionModel);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name !== undefined ? this.name : <any>null;
        data["typeAsString"] = this.typeAsString !== undefined ? this.typeAsString : <any>null;
        data["type"] = this.type !== undefined ? this.type : <any>null;
        data["typeSimple"] = this.typeSimple !== undefined ? this.typeSimple : <any>null;
        data["isOptional"] = this.isOptional !== undefined ? this.isOptional : <any>null;
        data["defaultValue"] = this.defaultValue !== undefined ? this.defaultValue : <any>null;
        return data; 
    }
}

export class ModuleApiDescriptionModel {
    rootPath!: string | null;
    remoteServiceName!: string | null;
    controllers!: { [key: string]: ControllerApiDescriptionModel; } | null;

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.rootPath = _data["rootPath"] !== undefined ? _data["rootPath"] : <any>null;
            this.remoteServiceName = _data["remoteServiceName"] !== undefined ? _data["remoteServiceName"] : <any>null;
            if (_data["controllers"]) {
                this.controllers = {} as any;
                for (let key in _data["controllers"]) {
                    if (_data["controllers"].hasOwnProperty(key))
                        (<any>this.controllers)![key] = _data["controllers"][key] ? ControllerApiDescriptionModel.fromJS(_data["controllers"][key], _mappings) : new ControllerApiDescriptionModel();
                }
            }
            else {
                this.controllers = <any>null;
            }
        }
    }

    static fromJS(data: any, _mappings?: any): ModuleApiDescriptionModel | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<ModuleApiDescriptionModel>(data, _mappings, ModuleApiDescriptionModel);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["rootPath"] = this.rootPath !== undefined ? this.rootPath : <any>null;
        data["remoteServiceName"] = this.remoteServiceName !== undefined ? this.remoteServiceName : <any>null;
        if (this.controllers) {
            data["controllers"] = {};
            for (let key in this.controllers) {
                if (this.controllers.hasOwnProperty(key))
                    (<any>data["controllers"])[key] = this.controllers[key] ? this.controllers[key].toJSON() : <any>null;
            }
        }
        return data; 
    }
}

export class ParameterApiDescriptionModel {
    nameOnMethod!: string | null;
    name!: string | null;
    jsonName!: string | null;
    type!: string | null;
    typeSimple!: string | null;
    isOptional!: boolean;
    defaultValue!: any | null;
    constraintTypes!: string[] | null;
    bindingSourceId!: string | null;
    descriptorName!: string | null;

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.nameOnMethod = _data["nameOnMethod"] !== undefined ? _data["nameOnMethod"] : <any>null;
            this.name = _data["name"] !== undefined ? _data["name"] : <any>null;
            this.jsonName = _data["jsonName"] !== undefined ? _data["jsonName"] : <any>null;
            this.type = _data["type"] !== undefined ? _data["type"] : <any>null;
            this.typeSimple = _data["typeSimple"] !== undefined ? _data["typeSimple"] : <any>null;
            this.isOptional = _data["isOptional"] !== undefined ? _data["isOptional"] : <any>null;
            this.defaultValue = _data["defaultValue"] !== undefined ? _data["defaultValue"] : <any>null;
            if (Array.isArray(_data["constraintTypes"])) {
                this.constraintTypes = [] as any;
                for (let item of _data["constraintTypes"])
                    this.constraintTypes!.push(item);
            }
            else {
                this.constraintTypes = <any>null;
            }
            this.bindingSourceId = _data["bindingSourceId"] !== undefined ? _data["bindingSourceId"] : <any>null;
            this.descriptorName = _data["descriptorName"] !== undefined ? _data["descriptorName"] : <any>null;
        }
    }

    static fromJS(data: any, _mappings?: any): ParameterApiDescriptionModel | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<ParameterApiDescriptionModel>(data, _mappings, ParameterApiDescriptionModel);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["nameOnMethod"] = this.nameOnMethod !== undefined ? this.nameOnMethod : <any>null;
        data["name"] = this.name !== undefined ? this.name : <any>null;
        data["jsonName"] = this.jsonName !== undefined ? this.jsonName : <any>null;
        data["type"] = this.type !== undefined ? this.type : <any>null;
        data["typeSimple"] = this.typeSimple !== undefined ? this.typeSimple : <any>null;
        data["isOptional"] = this.isOptional !== undefined ? this.isOptional : <any>null;
        data["defaultValue"] = this.defaultValue !== undefined ? this.defaultValue : <any>null;
        if (Array.isArray(this.constraintTypes)) {
            data["constraintTypes"] = [];
            for (let item of this.constraintTypes)
                data["constraintTypes"].push(item);
        }
        data["bindingSourceId"] = this.bindingSourceId !== undefined ? this.bindingSourceId : <any>null;
        data["descriptorName"] = this.descriptorName !== undefined ? this.descriptorName : <any>null;
        return data; 
    }
}

export class PropertyApiDescriptionModel {
    name!: string | null;
    jsonName!: string | null;
    type!: string | null;
    typeSimple!: string | null;
    isRequired!: boolean;

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.name = _data["name"] !== undefined ? _data["name"] : <any>null;
            this.jsonName = _data["jsonName"] !== undefined ? _data["jsonName"] : <any>null;
            this.type = _data["type"] !== undefined ? _data["type"] : <any>null;
            this.typeSimple = _data["typeSimple"] !== undefined ? _data["typeSimple"] : <any>null;
            this.isRequired = _data["isRequired"] !== undefined ? _data["isRequired"] : <any>null;
        }
    }

    static fromJS(data: any, _mappings?: any): PropertyApiDescriptionModel | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<PropertyApiDescriptionModel>(data, _mappings, PropertyApiDescriptionModel);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name !== undefined ? this.name : <any>null;
        data["jsonName"] = this.jsonName !== undefined ? this.jsonName : <any>null;
        data["type"] = this.type !== undefined ? this.type : <any>null;
        data["typeSimple"] = this.typeSimple !== undefined ? this.typeSimple : <any>null;
        data["isRequired"] = this.isRequired !== undefined ? this.isRequired : <any>null;
        return data; 
    }
}

export class ReturnValueApiDescriptionModel {
    type!: string | null;
    typeSimple!: string | null;

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.type = _data["type"] !== undefined ? _data["type"] : <any>null;
            this.typeSimple = _data["typeSimple"] !== undefined ? _data["typeSimple"] : <any>null;
        }
    }

    static fromJS(data: any, _mappings?: any): ReturnValueApiDescriptionModel | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<ReturnValueApiDescriptionModel>(data, _mappings, ReturnValueApiDescriptionModel);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["type"] = this.type !== undefined ? this.type : <any>null;
        data["typeSimple"] = this.typeSimple !== undefined ? this.typeSimple : <any>null;
        return data; 
    }
}

export class TypeApiDescriptionModel {
    baseType!: string | null;
    isEnum!: boolean;
    enumNames!: string[] | null;
    enumValues!: any[] | null;
    genericArguments!: string[] | null;
    properties!: PropertyApiDescriptionModel[] | null;

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.baseType = _data["baseType"] !== undefined ? _data["baseType"] : <any>null;
            this.isEnum = _data["isEnum"] !== undefined ? _data["isEnum"] : <any>null;
            if (Array.isArray(_data["enumNames"])) {
                this.enumNames = [] as any;
                for (let item of _data["enumNames"])
                    this.enumNames!.push(item);
            }
            else {
                this.enumNames = <any>null;
            }
            if (Array.isArray(_data["enumValues"])) {
                this.enumValues = [] as any;
                for (let item of _data["enumValues"])
                    this.enumValues!.push(item);
            }
            else {
                this.enumValues = <any>null;
            }
            if (Array.isArray(_data["genericArguments"])) {
                this.genericArguments = [] as any;
                for (let item of _data["genericArguments"])
                    this.genericArguments!.push(item);
            }
            else {
                this.genericArguments = <any>null;
            }
            if (Array.isArray(_data["properties"])) {
                this.properties = [] as any;
                for (let item of _data["properties"])
                    this.properties!.push(PropertyApiDescriptionModel.fromJS(item, _mappings));
            }
            else {
                this.properties = <any>null;
            }
        }
    }

    static fromJS(data: any, _mappings?: any): TypeApiDescriptionModel | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<TypeApiDescriptionModel>(data, _mappings, TypeApiDescriptionModel);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["baseType"] = this.baseType !== undefined ? this.baseType : <any>null;
        data["isEnum"] = this.isEnum !== undefined ? this.isEnum : <any>null;
        if (Array.isArray(this.enumNames)) {
            data["enumNames"] = [];
            for (let item of this.enumNames)
                data["enumNames"].push(item);
        }
        if (Array.isArray(this.enumValues)) {
            data["enumValues"] = [];
            for (let item of this.enumValues)
                data["enumValues"].push(item);
        }
        if (Array.isArray(this.genericArguments)) {
            data["genericArguments"] = [];
            for (let item of this.genericArguments)
                data["genericArguments"].push(item);
        }
        if (Array.isArray(this.properties)) {
            data["properties"] = [];
            for (let item of this.properties)
                data["properties"].push(item.toJSON());
        }
        return data; 
    }
}

export class RemoteServiceErrorInfo {
    code!: string | null;
    message!: string | null;
    details!: string | null;
    data!: { [key: string]: any; } | null;
    validationErrors!: RemoteServiceValidationErrorInfo[] | null;

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.code = _data["code"] !== undefined ? _data["code"] : <any>null;
            this.message = _data["message"] !== undefined ? _data["message"] : <any>null;
            this.details = _data["details"] !== undefined ? _data["details"] : <any>null;
            if (_data["data"]) {
                this.data = {} as any;
                for (let key in _data["data"]) {
                    if (_data["data"].hasOwnProperty(key))
                        (<any>this.data)![key] = _data["data"][key];
                }
            }
            else {
                this.data = <any>null;
            }
            if (Array.isArray(_data["validationErrors"])) {
                this.validationErrors = [] as any;
                for (let item of _data["validationErrors"])
                    this.validationErrors!.push(RemoteServiceValidationErrorInfo.fromJS(item, _mappings));
            }
            else {
                this.validationErrors = <any>null;
            }
        }
    }

    static fromJS(data: any, _mappings?: any): RemoteServiceErrorInfo | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<RemoteServiceErrorInfo>(data, _mappings, RemoteServiceErrorInfo);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code !== undefined ? this.code : <any>null;
        data["message"] = this.message !== undefined ? this.message : <any>null;
        data["details"] = this.details !== undefined ? this.details : <any>null;
        if (this.data) {
            data["data"] = {};
            for (let key in this.data) {
                if (this.data.hasOwnProperty(key))
                    (<any>data["data"])[key] = this.data[key] !== undefined ? this.data[key] : <any>null;
            }
        }
        if (Array.isArray(this.validationErrors)) {
            data["validationErrors"] = [];
            for (let item of this.validationErrors)
                data["validationErrors"].push(item.toJSON());
        }
        return data; 
    }
}

export class RemoteServiceErrorResponse {
    error!: RemoteServiceErrorInfo;

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.error = _data["error"] ? RemoteServiceErrorInfo.fromJS(_data["error"], _mappings) : <any>null;
        }
    }

    static fromJS(data: any, _mappings?: any): RemoteServiceErrorResponse | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<RemoteServiceErrorResponse>(data, _mappings, RemoteServiceErrorResponse);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["error"] = this.error ? this.error.toJSON() : <any>null;
        return data; 
    }
}

export class RemoteServiceValidationErrorInfo {
    message!: string | null;
    members!: string[] | null;

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.message = _data["message"] !== undefined ? _data["message"] : <any>null;
            if (Array.isArray(_data["members"])) {
                this.members = [] as any;
                for (let item of _data["members"])
                    this.members!.push(item);
            }
            else {
                this.members = <any>null;
            }
        }
    }

    static fromJS(data: any, _mappings?: any): RemoteServiceValidationErrorInfo | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<RemoteServiceValidationErrorInfo>(data, _mappings, RemoteServiceValidationErrorInfo);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["message"] = this.message !== undefined ? this.message : <any>null;
        if (Array.isArray(this.members)) {
            data["members"] = [];
            for (let item of this.members)
                data["members"].push(item);
        }
        return data; 
    }
}

export class ChangePasswordInput {
    currentPassword!: string | null;
    newPassword!: string;

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.currentPassword = _data["currentPassword"] !== undefined ? _data["currentPassword"] : <any>null;
            this.newPassword = _data["newPassword"] !== undefined ? _data["newPassword"] : <any>null;
        }
    }

    static fromJS(data: any, _mappings?: any): ChangePasswordInput | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<ChangePasswordInput>(data, _mappings, ChangePasswordInput);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["currentPassword"] = this.currentPassword !== undefined ? this.currentPassword : <any>null;
        data["newPassword"] = this.newPassword !== undefined ? this.newPassword : <any>null;
        return data; 
    }
}

export class IdentityRoleCreateDto {
    readonly extraProperties!: { [key: string]: any; } | null;
    name!: string;
    isDefault!: boolean;
    isPublic!: boolean;

    init(_data?: any, _mappings?: any) {
        if (_data) {
            if (_data["extraProperties"]) {
                (<any>this).extraProperties = {} as any;
                for (let key in _data["extraProperties"]) {
                    if (_data["extraProperties"].hasOwnProperty(key))
                        (<any>(<any>this).extraProperties)![key] = _data["extraProperties"][key];
                }
            }
            else {
                (<any>this).extraProperties = <any>null;
            }
            this.name = _data["name"] !== undefined ? _data["name"] : <any>null;
            this.isDefault = _data["isDefault"] !== undefined ? _data["isDefault"] : <any>null;
            this.isPublic = _data["isPublic"] !== undefined ? _data["isPublic"] : <any>null;
        }
    }

    static fromJS(data: any, _mappings?: any): IdentityRoleCreateDto | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<IdentityRoleCreateDto>(data, _mappings, IdentityRoleCreateDto);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.extraProperties) {
            data["extraProperties"] = {};
            for (let key in this.extraProperties) {
                if (this.extraProperties.hasOwnProperty(key))
                    (<any>data["extraProperties"])[key] = this.extraProperties[key] !== undefined ? this.extraProperties[key] : <any>null;
            }
        }
        data["name"] = this.name !== undefined ? this.name : <any>null;
        data["isDefault"] = this.isDefault !== undefined ? this.isDefault : <any>null;
        data["isPublic"] = this.isPublic !== undefined ? this.isPublic : <any>null;
        return data; 
    }
}

export class IdentityRoleDto {
    readonly extraProperties!: { [key: string]: any; } | null;
    id!: string;
    name!: string | null;
    isDefault!: boolean;
    isStatic!: boolean;
    isPublic!: boolean;
    concurrencyStamp!: string | null;

    init(_data?: any, _mappings?: any) {
        if (_data) {
            if (_data["extraProperties"]) {
                (<any>this).extraProperties = {} as any;
                for (let key in _data["extraProperties"]) {
                    if (_data["extraProperties"].hasOwnProperty(key))
                        (<any>(<any>this).extraProperties)![key] = _data["extraProperties"][key];
                }
            }
            else {
                (<any>this).extraProperties = <any>null;
            }
            this.id = _data["id"] !== undefined ? _data["id"] : <any>null;
            this.name = _data["name"] !== undefined ? _data["name"] : <any>null;
            this.isDefault = _data["isDefault"] !== undefined ? _data["isDefault"] : <any>null;
            this.isStatic = _data["isStatic"] !== undefined ? _data["isStatic"] : <any>null;
            this.isPublic = _data["isPublic"] !== undefined ? _data["isPublic"] : <any>null;
            this.concurrencyStamp = _data["concurrencyStamp"] !== undefined ? _data["concurrencyStamp"] : <any>null;
        }
    }

    static fromJS(data: any, _mappings?: any): IdentityRoleDto | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<IdentityRoleDto>(data, _mappings, IdentityRoleDto);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.extraProperties) {
            data["extraProperties"] = {};
            for (let key in this.extraProperties) {
                if (this.extraProperties.hasOwnProperty(key))
                    (<any>data["extraProperties"])[key] = this.extraProperties[key] !== undefined ? this.extraProperties[key] : <any>null;
            }
        }
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["name"] = this.name !== undefined ? this.name : <any>null;
        data["isDefault"] = this.isDefault !== undefined ? this.isDefault : <any>null;
        data["isStatic"] = this.isStatic !== undefined ? this.isStatic : <any>null;
        data["isPublic"] = this.isPublic !== undefined ? this.isPublic : <any>null;
        data["concurrencyStamp"] = this.concurrencyStamp !== undefined ? this.concurrencyStamp : <any>null;
        return data; 
    }
}

export class IdentityRoleUpdateDto {
    readonly extraProperties!: { [key: string]: any; } | null;
    name!: string;
    isDefault!: boolean;
    isPublic!: boolean;
    concurrencyStamp!: string | null;

    init(_data?: any, _mappings?: any) {
        if (_data) {
            if (_data["extraProperties"]) {
                (<any>this).extraProperties = {} as any;
                for (let key in _data["extraProperties"]) {
                    if (_data["extraProperties"].hasOwnProperty(key))
                        (<any>(<any>this).extraProperties)![key] = _data["extraProperties"][key];
                }
            }
            else {
                (<any>this).extraProperties = <any>null;
            }
            this.name = _data["name"] !== undefined ? _data["name"] : <any>null;
            this.isDefault = _data["isDefault"] !== undefined ? _data["isDefault"] : <any>null;
            this.isPublic = _data["isPublic"] !== undefined ? _data["isPublic"] : <any>null;
            this.concurrencyStamp = _data["concurrencyStamp"] !== undefined ? _data["concurrencyStamp"] : <any>null;
        }
    }

    static fromJS(data: any, _mappings?: any): IdentityRoleUpdateDto | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<IdentityRoleUpdateDto>(data, _mappings, IdentityRoleUpdateDto);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.extraProperties) {
            data["extraProperties"] = {};
            for (let key in this.extraProperties) {
                if (this.extraProperties.hasOwnProperty(key))
                    (<any>data["extraProperties"])[key] = this.extraProperties[key] !== undefined ? this.extraProperties[key] : <any>null;
            }
        }
        data["name"] = this.name !== undefined ? this.name : <any>null;
        data["isDefault"] = this.isDefault !== undefined ? this.isDefault : <any>null;
        data["isPublic"] = this.isPublic !== undefined ? this.isPublic : <any>null;
        data["concurrencyStamp"] = this.concurrencyStamp !== undefined ? this.concurrencyStamp : <any>null;
        return data; 
    }
}

export class IdentityUserCreateDto {
    readonly extraProperties!: { [key: string]: any; } | null;
    userName!: string;
    name!: string | null;
    surname!: string | null;
    email!: string;
    phoneNumber!: string | null;
    lockoutEnabled!: boolean;
    roleNames!: string[] | null;
    password!: string;

    init(_data?: any, _mappings?: any) {
        if (_data) {
            if (_data["extraProperties"]) {
                (<any>this).extraProperties = {} as any;
                for (let key in _data["extraProperties"]) {
                    if (_data["extraProperties"].hasOwnProperty(key))
                        (<any>(<any>this).extraProperties)![key] = _data["extraProperties"][key];
                }
            }
            else {
                (<any>this).extraProperties = <any>null;
            }
            this.userName = _data["userName"] !== undefined ? _data["userName"] : <any>null;
            this.name = _data["name"] !== undefined ? _data["name"] : <any>null;
            this.surname = _data["surname"] !== undefined ? _data["surname"] : <any>null;
            this.email = _data["email"] !== undefined ? _data["email"] : <any>null;
            this.phoneNumber = _data["phoneNumber"] !== undefined ? _data["phoneNumber"] : <any>null;
            this.lockoutEnabled = _data["lockoutEnabled"] !== undefined ? _data["lockoutEnabled"] : <any>null;
            if (Array.isArray(_data["roleNames"])) {
                this.roleNames = [] as any;
                for (let item of _data["roleNames"])
                    this.roleNames!.push(item);
            }
            else {
                this.roleNames = <any>null;
            }
            this.password = _data["password"] !== undefined ? _data["password"] : <any>null;
        }
    }

    static fromJS(data: any, _mappings?: any): IdentityUserCreateDto | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<IdentityUserCreateDto>(data, _mappings, IdentityUserCreateDto);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.extraProperties) {
            data["extraProperties"] = {};
            for (let key in this.extraProperties) {
                if (this.extraProperties.hasOwnProperty(key))
                    (<any>data["extraProperties"])[key] = this.extraProperties[key] !== undefined ? this.extraProperties[key] : <any>null;
            }
        }
        data["userName"] = this.userName !== undefined ? this.userName : <any>null;
        data["name"] = this.name !== undefined ? this.name : <any>null;
        data["surname"] = this.surname !== undefined ? this.surname : <any>null;
        data["email"] = this.email !== undefined ? this.email : <any>null;
        data["phoneNumber"] = this.phoneNumber !== undefined ? this.phoneNumber : <any>null;
        data["lockoutEnabled"] = this.lockoutEnabled !== undefined ? this.lockoutEnabled : <any>null;
        if (Array.isArray(this.roleNames)) {
            data["roleNames"] = [];
            for (let item of this.roleNames)
                data["roleNames"].push(item);
        }
        data["password"] = this.password !== undefined ? this.password : <any>null;
        return data; 
    }
}

export class IdentityUserDto {
    readonly extraProperties!: { [key: string]: any; } | null;
    id!: string;
    creationTime!: Date;
    creatorId!: string | null;
    lastModificationTime!: Date | null;
    lastModifierId!: string | null;
    isDeleted!: boolean;
    deleterId!: string | null;
    deletionTime!: Date | null;
    tenantId!: string | null;
    userName!: string | null;
    name!: string | null;
    surname!: string | null;
    email!: string | null;
    emailConfirmed!: boolean;
    phoneNumber!: string | null;
    phoneNumberConfirmed!: boolean;
    lockoutEnabled!: boolean;
    lockoutEnd!: Date | null;
    concurrencyStamp!: string | null;

    init(_data?: any, _mappings?: any) {
        if (_data) {
            if (_data["extraProperties"]) {
                (<any>this).extraProperties = {} as any;
                for (let key in _data["extraProperties"]) {
                    if (_data["extraProperties"].hasOwnProperty(key))
                        (<any>(<any>this).extraProperties)![key] = _data["extraProperties"][key];
                }
            }
            else {
                (<any>this).extraProperties = <any>null;
            }
            this.id = _data["id"] !== undefined ? _data["id"] : <any>null;
            this.creationTime = _data["creationTime"] ? new Date(_data["creationTime"].toString()) : <any>null;
            this.creatorId = _data["creatorId"] !== undefined ? _data["creatorId"] : <any>null;
            this.lastModificationTime = _data["lastModificationTime"] ? new Date(_data["lastModificationTime"].toString()) : <any>null;
            this.lastModifierId = _data["lastModifierId"] !== undefined ? _data["lastModifierId"] : <any>null;
            this.isDeleted = _data["isDeleted"] !== undefined ? _data["isDeleted"] : <any>null;
            this.deleterId = _data["deleterId"] !== undefined ? _data["deleterId"] : <any>null;
            this.deletionTime = _data["deletionTime"] ? new Date(_data["deletionTime"].toString()) : <any>null;
            this.tenantId = _data["tenantId"] !== undefined ? _data["tenantId"] : <any>null;
            this.userName = _data["userName"] !== undefined ? _data["userName"] : <any>null;
            this.name = _data["name"] !== undefined ? _data["name"] : <any>null;
            this.surname = _data["surname"] !== undefined ? _data["surname"] : <any>null;
            this.email = _data["email"] !== undefined ? _data["email"] : <any>null;
            this.emailConfirmed = _data["emailConfirmed"] !== undefined ? _data["emailConfirmed"] : <any>null;
            this.phoneNumber = _data["phoneNumber"] !== undefined ? _data["phoneNumber"] : <any>null;
            this.phoneNumberConfirmed = _data["phoneNumberConfirmed"] !== undefined ? _data["phoneNumberConfirmed"] : <any>null;
            this.lockoutEnabled = _data["lockoutEnabled"] !== undefined ? _data["lockoutEnabled"] : <any>null;
            this.lockoutEnd = _data["lockoutEnd"] ? new Date(_data["lockoutEnd"].toString()) : <any>null;
            this.concurrencyStamp = _data["concurrencyStamp"] !== undefined ? _data["concurrencyStamp"] : <any>null;
        }
    }

    static fromJS(data: any, _mappings?: any): IdentityUserDto | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<IdentityUserDto>(data, _mappings, IdentityUserDto);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.extraProperties) {
            data["extraProperties"] = {};
            for (let key in this.extraProperties) {
                if (this.extraProperties.hasOwnProperty(key))
                    (<any>data["extraProperties"])[key] = this.extraProperties[key] !== undefined ? this.extraProperties[key] : <any>null;
            }
        }
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>null;
        data["creatorId"] = this.creatorId !== undefined ? this.creatorId : <any>null;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>null;
        data["lastModifierId"] = this.lastModifierId !== undefined ? this.lastModifierId : <any>null;
        data["isDeleted"] = this.isDeleted !== undefined ? this.isDeleted : <any>null;
        data["deleterId"] = this.deleterId !== undefined ? this.deleterId : <any>null;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>null;
        data["tenantId"] = this.tenantId !== undefined ? this.tenantId : <any>null;
        data["userName"] = this.userName !== undefined ? this.userName : <any>null;
        data["name"] = this.name !== undefined ? this.name : <any>null;
        data["surname"] = this.surname !== undefined ? this.surname : <any>null;
        data["email"] = this.email !== undefined ? this.email : <any>null;
        data["emailConfirmed"] = this.emailConfirmed !== undefined ? this.emailConfirmed : <any>null;
        data["phoneNumber"] = this.phoneNumber !== undefined ? this.phoneNumber : <any>null;
        data["phoneNumberConfirmed"] = this.phoneNumberConfirmed !== undefined ? this.phoneNumberConfirmed : <any>null;
        data["lockoutEnabled"] = this.lockoutEnabled !== undefined ? this.lockoutEnabled : <any>null;
        data["lockoutEnd"] = this.lockoutEnd ? this.lockoutEnd.toISOString() : <any>null;
        data["concurrencyStamp"] = this.concurrencyStamp !== undefined ? this.concurrencyStamp : <any>null;
        return data; 
    }
}

export class IdentityUserUpdateDto {
    readonly extraProperties!: { [key: string]: any; } | null;
    userName!: string;
    name!: string | null;
    surname!: string | null;
    email!: string;
    phoneNumber!: string | null;
    lockoutEnabled!: boolean;
    roleNames!: string[] | null;
    password!: string | null;
    concurrencyStamp!: string | null;

    init(_data?: any, _mappings?: any) {
        if (_data) {
            if (_data["extraProperties"]) {
                (<any>this).extraProperties = {} as any;
                for (let key in _data["extraProperties"]) {
                    if (_data["extraProperties"].hasOwnProperty(key))
                        (<any>(<any>this).extraProperties)![key] = _data["extraProperties"][key];
                }
            }
            else {
                (<any>this).extraProperties = <any>null;
            }
            this.userName = _data["userName"] !== undefined ? _data["userName"] : <any>null;
            this.name = _data["name"] !== undefined ? _data["name"] : <any>null;
            this.surname = _data["surname"] !== undefined ? _data["surname"] : <any>null;
            this.email = _data["email"] !== undefined ? _data["email"] : <any>null;
            this.phoneNumber = _data["phoneNumber"] !== undefined ? _data["phoneNumber"] : <any>null;
            this.lockoutEnabled = _data["lockoutEnabled"] !== undefined ? _data["lockoutEnabled"] : <any>null;
            if (Array.isArray(_data["roleNames"])) {
                this.roleNames = [] as any;
                for (let item of _data["roleNames"])
                    this.roleNames!.push(item);
            }
            else {
                this.roleNames = <any>null;
            }
            this.password = _data["password"] !== undefined ? _data["password"] : <any>null;
            this.concurrencyStamp = _data["concurrencyStamp"] !== undefined ? _data["concurrencyStamp"] : <any>null;
        }
    }

    static fromJS(data: any, _mappings?: any): IdentityUserUpdateDto | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<IdentityUserUpdateDto>(data, _mappings, IdentityUserUpdateDto);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.extraProperties) {
            data["extraProperties"] = {};
            for (let key in this.extraProperties) {
                if (this.extraProperties.hasOwnProperty(key))
                    (<any>data["extraProperties"])[key] = this.extraProperties[key] !== undefined ? this.extraProperties[key] : <any>null;
            }
        }
        data["userName"] = this.userName !== undefined ? this.userName : <any>null;
        data["name"] = this.name !== undefined ? this.name : <any>null;
        data["surname"] = this.surname !== undefined ? this.surname : <any>null;
        data["email"] = this.email !== undefined ? this.email : <any>null;
        data["phoneNumber"] = this.phoneNumber !== undefined ? this.phoneNumber : <any>null;
        data["lockoutEnabled"] = this.lockoutEnabled !== undefined ? this.lockoutEnabled : <any>null;
        if (Array.isArray(this.roleNames)) {
            data["roleNames"] = [];
            for (let item of this.roleNames)
                data["roleNames"].push(item);
        }
        data["password"] = this.password !== undefined ? this.password : <any>null;
        data["concurrencyStamp"] = this.concurrencyStamp !== undefined ? this.concurrencyStamp : <any>null;
        return data; 
    }
}

export class IdentityUserUpdateRolesDto {
    roleNames!: string[];

    init(_data?: any, _mappings?: any) {
        if (_data) {
            if (Array.isArray(_data["roleNames"])) {
                this.roleNames = [] as any;
                for (let item of _data["roleNames"])
                    this.roleNames!.push(item);
            }
            else {
                this.roleNames = <any>null;
            }
        }
    }

    static fromJS(data: any, _mappings?: any): IdentityUserUpdateRolesDto | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<IdentityUserUpdateRolesDto>(data, _mappings, IdentityUserUpdateRolesDto);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.roleNames)) {
            data["roleNames"] = [];
            for (let item of this.roleNames)
                data["roleNames"].push(item);
        }
        return data; 
    }
}

export class ProfileDto {
    readonly extraProperties!: { [key: string]: any; } | null;
    userName!: string | null;
    email!: string | null;
    name!: string | null;
    surname!: string | null;
    phoneNumber!: string | null;
    isExternal!: boolean;
    hasPassword!: boolean;

    init(_data?: any, _mappings?: any) {
        if (_data) {
            if (_data["extraProperties"]) {
                (<any>this).extraProperties = {} as any;
                for (let key in _data["extraProperties"]) {
                    if (_data["extraProperties"].hasOwnProperty(key))
                        (<any>(<any>this).extraProperties)![key] = _data["extraProperties"][key];
                }
            }
            else {
                (<any>this).extraProperties = <any>null;
            }
            this.userName = _data["userName"] !== undefined ? _data["userName"] : <any>null;
            this.email = _data["email"] !== undefined ? _data["email"] : <any>null;
            this.name = _data["name"] !== undefined ? _data["name"] : <any>null;
            this.surname = _data["surname"] !== undefined ? _data["surname"] : <any>null;
            this.phoneNumber = _data["phoneNumber"] !== undefined ? _data["phoneNumber"] : <any>null;
            this.isExternal = _data["isExternal"] !== undefined ? _data["isExternal"] : <any>null;
            this.hasPassword = _data["hasPassword"] !== undefined ? _data["hasPassword"] : <any>null;
        }
    }

    static fromJS(data: any, _mappings?: any): ProfileDto | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<ProfileDto>(data, _mappings, ProfileDto);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.extraProperties) {
            data["extraProperties"] = {};
            for (let key in this.extraProperties) {
                if (this.extraProperties.hasOwnProperty(key))
                    (<any>data["extraProperties"])[key] = this.extraProperties[key] !== undefined ? this.extraProperties[key] : <any>null;
            }
        }
        data["userName"] = this.userName !== undefined ? this.userName : <any>null;
        data["email"] = this.email !== undefined ? this.email : <any>null;
        data["name"] = this.name !== undefined ? this.name : <any>null;
        data["surname"] = this.surname !== undefined ? this.surname : <any>null;
        data["phoneNumber"] = this.phoneNumber !== undefined ? this.phoneNumber : <any>null;
        data["isExternal"] = this.isExternal !== undefined ? this.isExternal : <any>null;
        data["hasPassword"] = this.hasPassword !== undefined ? this.hasPassword : <any>null;
        return data; 
    }
}

export class UpdateProfileDto {
    readonly extraProperties!: { [key: string]: any; } | null;
    userName!: string | null;
    email!: string | null;
    name!: string | null;
    surname!: string | null;
    phoneNumber!: string | null;

    init(_data?: any, _mappings?: any) {
        if (_data) {
            if (_data["extraProperties"]) {
                (<any>this).extraProperties = {} as any;
                for (let key in _data["extraProperties"]) {
                    if (_data["extraProperties"].hasOwnProperty(key))
                        (<any>(<any>this).extraProperties)![key] = _data["extraProperties"][key];
                }
            }
            else {
                (<any>this).extraProperties = <any>null;
            }
            this.userName = _data["userName"] !== undefined ? _data["userName"] : <any>null;
            this.email = _data["email"] !== undefined ? _data["email"] : <any>null;
            this.name = _data["name"] !== undefined ? _data["name"] : <any>null;
            this.surname = _data["surname"] !== undefined ? _data["surname"] : <any>null;
            this.phoneNumber = _data["phoneNumber"] !== undefined ? _data["phoneNumber"] : <any>null;
        }
    }

    static fromJS(data: any, _mappings?: any): UpdateProfileDto | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<UpdateProfileDto>(data, _mappings, UpdateProfileDto);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.extraProperties) {
            data["extraProperties"] = {};
            for (let key in this.extraProperties) {
                if (this.extraProperties.hasOwnProperty(key))
                    (<any>data["extraProperties"])[key] = this.extraProperties[key] !== undefined ? this.extraProperties[key] : <any>null;
            }
        }
        data["userName"] = this.userName !== undefined ? this.userName : <any>null;
        data["email"] = this.email !== undefined ? this.email : <any>null;
        data["name"] = this.name !== undefined ? this.name : <any>null;
        data["surname"] = this.surname !== undefined ? this.surname : <any>null;
        data["phoneNumber"] = this.phoneNumber !== undefined ? this.phoneNumber : <any>null;
        return data; 
    }
}

export class LanguageInfo {
    readonly cultureName!: string | null;
    readonly uiCultureName!: string | null;
    readonly displayName!: string | null;
    flagIcon!: string | null;

    init(_data?: any, _mappings?: any) {
        if (_data) {
            (<any>this).cultureName = _data["cultureName"] !== undefined ? _data["cultureName"] : <any>null;
            (<any>this).uiCultureName = _data["uiCultureName"] !== undefined ? _data["uiCultureName"] : <any>null;
            (<any>this).displayName = _data["displayName"] !== undefined ? _data["displayName"] : <any>null;
            this.flagIcon = _data["flagIcon"] !== undefined ? _data["flagIcon"] : <any>null;
        }
    }

    static fromJS(data: any, _mappings?: any): LanguageInfo | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<LanguageInfo>(data, _mappings, LanguageInfo);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["cultureName"] = this.cultureName !== undefined ? this.cultureName : <any>null;
        data["uiCultureName"] = this.uiCultureName !== undefined ? this.uiCultureName : <any>null;
        data["displayName"] = this.displayName !== undefined ? this.displayName : <any>null;
        data["flagIcon"] = this.flagIcon !== undefined ? this.flagIcon : <any>null;
        return data; 
    }
}

export class NameValue {
    name!: string | null;
    value!: string | null;

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.name = _data["name"] !== undefined ? _data["name"] : <any>null;
            this.value = _data["value"] !== undefined ? _data["value"] : <any>null;
        }
    }

    static fromJS(data: any, _mappings?: any): NameValue | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<NameValue>(data, _mappings, NameValue);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name !== undefined ? this.name : <any>null;
        data["value"] = this.value !== undefined ? this.value : <any>null;
        return data; 
    }
}

export class GetPermissionListResultDto {
    entityDisplayName!: string | null;
    groups!: PermissionGroupDto[] | null;

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.entityDisplayName = _data["entityDisplayName"] !== undefined ? _data["entityDisplayName"] : <any>null;
            if (Array.isArray(_data["groups"])) {
                this.groups = [] as any;
                for (let item of _data["groups"])
                    this.groups!.push(PermissionGroupDto.fromJS(item, _mappings));
            }
            else {
                this.groups = <any>null;
            }
        }
    }

    static fromJS(data: any, _mappings?: any): GetPermissionListResultDto | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<GetPermissionListResultDto>(data, _mappings, GetPermissionListResultDto);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["entityDisplayName"] = this.entityDisplayName !== undefined ? this.entityDisplayName : <any>null;
        if (Array.isArray(this.groups)) {
            data["groups"] = [];
            for (let item of this.groups)
                data["groups"].push(item.toJSON());
        }
        return data; 
    }
}

export class PermissionGrantInfoDto {
    name!: string | null;
    displayName!: string | null;
    parentName!: string | null;
    isGranted!: boolean;
    allowedProviders!: string[] | null;
    grantedProviders!: ProviderInfoDto[] | null;

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.name = _data["name"] !== undefined ? _data["name"] : <any>null;
            this.displayName = _data["displayName"] !== undefined ? _data["displayName"] : <any>null;
            this.parentName = _data["parentName"] !== undefined ? _data["parentName"] : <any>null;
            this.isGranted = _data["isGranted"] !== undefined ? _data["isGranted"] : <any>null;
            if (Array.isArray(_data["allowedProviders"])) {
                this.allowedProviders = [] as any;
                for (let item of _data["allowedProviders"])
                    this.allowedProviders!.push(item);
            }
            else {
                this.allowedProviders = <any>null;
            }
            if (Array.isArray(_data["grantedProviders"])) {
                this.grantedProviders = [] as any;
                for (let item of _data["grantedProviders"])
                    this.grantedProviders!.push(ProviderInfoDto.fromJS(item, _mappings));
            }
            else {
                this.grantedProviders = <any>null;
            }
        }
    }

    static fromJS(data: any, _mappings?: any): PermissionGrantInfoDto | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<PermissionGrantInfoDto>(data, _mappings, PermissionGrantInfoDto);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name !== undefined ? this.name : <any>null;
        data["displayName"] = this.displayName !== undefined ? this.displayName : <any>null;
        data["parentName"] = this.parentName !== undefined ? this.parentName : <any>null;
        data["isGranted"] = this.isGranted !== undefined ? this.isGranted : <any>null;
        if (Array.isArray(this.allowedProviders)) {
            data["allowedProviders"] = [];
            for (let item of this.allowedProviders)
                data["allowedProviders"].push(item);
        }
        if (Array.isArray(this.grantedProviders)) {
            data["grantedProviders"] = [];
            for (let item of this.grantedProviders)
                data["grantedProviders"].push(item.toJSON());
        }
        return data; 
    }
}

export class PermissionGroupDto {
    name!: string | null;
    displayName!: string | null;
    permissions!: PermissionGrantInfoDto[] | null;

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.name = _data["name"] !== undefined ? _data["name"] : <any>null;
            this.displayName = _data["displayName"] !== undefined ? _data["displayName"] : <any>null;
            if (Array.isArray(_data["permissions"])) {
                this.permissions = [] as any;
                for (let item of _data["permissions"])
                    this.permissions!.push(PermissionGrantInfoDto.fromJS(item, _mappings));
            }
            else {
                this.permissions = <any>null;
            }
        }
    }

    static fromJS(data: any, _mappings?: any): PermissionGroupDto | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<PermissionGroupDto>(data, _mappings, PermissionGroupDto);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name !== undefined ? this.name : <any>null;
        data["displayName"] = this.displayName !== undefined ? this.displayName : <any>null;
        if (Array.isArray(this.permissions)) {
            data["permissions"] = [];
            for (let item of this.permissions)
                data["permissions"].push(item.toJSON());
        }
        return data; 
    }
}

export class ProviderInfoDto {
    providerName!: string | null;
    providerKey!: string | null;

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.providerName = _data["providerName"] !== undefined ? _data["providerName"] : <any>null;
            this.providerKey = _data["providerKey"] !== undefined ? _data["providerKey"] : <any>null;
        }
    }

    static fromJS(data: any, _mappings?: any): ProviderInfoDto | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<ProviderInfoDto>(data, _mappings, ProviderInfoDto);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["providerName"] = this.providerName !== undefined ? this.providerName : <any>null;
        data["providerKey"] = this.providerKey !== undefined ? this.providerKey : <any>null;
        return data; 
    }
}

export class UpdatePermissionDto {
    name!: string | null;
    isGranted!: boolean;

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.name = _data["name"] !== undefined ? _data["name"] : <any>null;
            this.isGranted = _data["isGranted"] !== undefined ? _data["isGranted"] : <any>null;
        }
    }

    static fromJS(data: any, _mappings?: any): UpdatePermissionDto | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<UpdatePermissionDto>(data, _mappings, UpdatePermissionDto);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name !== undefined ? this.name : <any>null;
        data["isGranted"] = this.isGranted !== undefined ? this.isGranted : <any>null;
        return data; 
    }
}

export class UpdatePermissionsDto {
    permissions!: UpdatePermissionDto[] | null;

    init(_data?: any, _mappings?: any) {
        if (_data) {
            if (Array.isArray(_data["permissions"])) {
                this.permissions = [] as any;
                for (let item of _data["permissions"])
                    this.permissions!.push(UpdatePermissionDto.fromJS(item, _mappings));
            }
            else {
                this.permissions = <any>null;
            }
        }
    }

    static fromJS(data: any, _mappings?: any): UpdatePermissionsDto | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<UpdatePermissionsDto>(data, _mappings, UpdatePermissionsDto);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.permissions)) {
            data["permissions"] = [];
            for (let item of this.permissions)
                data["permissions"].push(item.toJSON());
        }
        return data; 
    }
}

export class EmailSettingsDto {
    smtpHost!: string | null;
    smtpPort!: number;
    smtpUserName!: string | null;
    smtpPassword!: string | null;
    smtpDomain!: string | null;
    smtpEnableSsl!: boolean;
    smtpUseDefaultCredentials!: boolean;
    defaultFromAddress!: string | null;
    defaultFromDisplayName!: string | null;

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.smtpHost = _data["smtpHost"] !== undefined ? _data["smtpHost"] : <any>null;
            this.smtpPort = _data["smtpPort"] !== undefined ? _data["smtpPort"] : <any>null;
            this.smtpUserName = _data["smtpUserName"] !== undefined ? _data["smtpUserName"] : <any>null;
            this.smtpPassword = _data["smtpPassword"] !== undefined ? _data["smtpPassword"] : <any>null;
            this.smtpDomain = _data["smtpDomain"] !== undefined ? _data["smtpDomain"] : <any>null;
            this.smtpEnableSsl = _data["smtpEnableSsl"] !== undefined ? _data["smtpEnableSsl"] : <any>null;
            this.smtpUseDefaultCredentials = _data["smtpUseDefaultCredentials"] !== undefined ? _data["smtpUseDefaultCredentials"] : <any>null;
            this.defaultFromAddress = _data["defaultFromAddress"] !== undefined ? _data["defaultFromAddress"] : <any>null;
            this.defaultFromDisplayName = _data["defaultFromDisplayName"] !== undefined ? _data["defaultFromDisplayName"] : <any>null;
        }
    }

    static fromJS(data: any, _mappings?: any): EmailSettingsDto | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<EmailSettingsDto>(data, _mappings, EmailSettingsDto);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["smtpHost"] = this.smtpHost !== undefined ? this.smtpHost : <any>null;
        data["smtpPort"] = this.smtpPort !== undefined ? this.smtpPort : <any>null;
        data["smtpUserName"] = this.smtpUserName !== undefined ? this.smtpUserName : <any>null;
        data["smtpPassword"] = this.smtpPassword !== undefined ? this.smtpPassword : <any>null;
        data["smtpDomain"] = this.smtpDomain !== undefined ? this.smtpDomain : <any>null;
        data["smtpEnableSsl"] = this.smtpEnableSsl !== undefined ? this.smtpEnableSsl : <any>null;
        data["smtpUseDefaultCredentials"] = this.smtpUseDefaultCredentials !== undefined ? this.smtpUseDefaultCredentials : <any>null;
        data["defaultFromAddress"] = this.defaultFromAddress !== undefined ? this.defaultFromAddress : <any>null;
        data["defaultFromDisplayName"] = this.defaultFromDisplayName !== undefined ? this.defaultFromDisplayName : <any>null;
        return data; 
    }
}

export class UpdateEmailSettingsDto {
    smtpHost!: string | null;
    smtpPort!: number;
    smtpUserName!: string | null;
    smtpPassword!: string | null;
    smtpDomain!: string | null;
    smtpEnableSsl!: boolean;
    smtpUseDefaultCredentials!: boolean;
    defaultFromAddress!: string;
    defaultFromDisplayName!: string;

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.smtpHost = _data["smtpHost"] !== undefined ? _data["smtpHost"] : <any>null;
            this.smtpPort = _data["smtpPort"] !== undefined ? _data["smtpPort"] : <any>null;
            this.smtpUserName = _data["smtpUserName"] !== undefined ? _data["smtpUserName"] : <any>null;
            this.smtpPassword = _data["smtpPassword"] !== undefined ? _data["smtpPassword"] : <any>null;
            this.smtpDomain = _data["smtpDomain"] !== undefined ? _data["smtpDomain"] : <any>null;
            this.smtpEnableSsl = _data["smtpEnableSsl"] !== undefined ? _data["smtpEnableSsl"] : <any>null;
            this.smtpUseDefaultCredentials = _data["smtpUseDefaultCredentials"] !== undefined ? _data["smtpUseDefaultCredentials"] : <any>null;
            this.defaultFromAddress = _data["defaultFromAddress"] !== undefined ? _data["defaultFromAddress"] : <any>null;
            this.defaultFromDisplayName = _data["defaultFromDisplayName"] !== undefined ? _data["defaultFromDisplayName"] : <any>null;
        }
    }

    static fromJS(data: any, _mappings?: any): UpdateEmailSettingsDto | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<UpdateEmailSettingsDto>(data, _mappings, UpdateEmailSettingsDto);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["smtpHost"] = this.smtpHost !== undefined ? this.smtpHost : <any>null;
        data["smtpPort"] = this.smtpPort !== undefined ? this.smtpPort : <any>null;
        data["smtpUserName"] = this.smtpUserName !== undefined ? this.smtpUserName : <any>null;
        data["smtpPassword"] = this.smtpPassword !== undefined ? this.smtpPassword : <any>null;
        data["smtpDomain"] = this.smtpDomain !== undefined ? this.smtpDomain : <any>null;
        data["smtpEnableSsl"] = this.smtpEnableSsl !== undefined ? this.smtpEnableSsl : <any>null;
        data["smtpUseDefaultCredentials"] = this.smtpUseDefaultCredentials !== undefined ? this.smtpUseDefaultCredentials : <any>null;
        data["defaultFromAddress"] = this.defaultFromAddress !== undefined ? this.defaultFromAddress : <any>null;
        data["defaultFromDisplayName"] = this.defaultFromDisplayName !== undefined ? this.defaultFromDisplayName : <any>null;
        return data; 
    }
}

export class TenantCreateDto {
    readonly extraProperties!: { [key: string]: any; } | null;
    name!: string;
    adminEmailAddress!: string;
    adminPassword!: string;

    init(_data?: any, _mappings?: any) {
        if (_data) {
            if (_data["extraProperties"]) {
                (<any>this).extraProperties = {} as any;
                for (let key in _data["extraProperties"]) {
                    if (_data["extraProperties"].hasOwnProperty(key))
                        (<any>(<any>this).extraProperties)![key] = _data["extraProperties"][key];
                }
            }
            else {
                (<any>this).extraProperties = <any>null;
            }
            this.name = _data["name"] !== undefined ? _data["name"] : <any>null;
            this.adminEmailAddress = _data["adminEmailAddress"] !== undefined ? _data["adminEmailAddress"] : <any>null;
            this.adminPassword = _data["adminPassword"] !== undefined ? _data["adminPassword"] : <any>null;
        }
    }

    static fromJS(data: any, _mappings?: any): TenantCreateDto | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<TenantCreateDto>(data, _mappings, TenantCreateDto);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.extraProperties) {
            data["extraProperties"] = {};
            for (let key in this.extraProperties) {
                if (this.extraProperties.hasOwnProperty(key))
                    (<any>data["extraProperties"])[key] = this.extraProperties[key] !== undefined ? this.extraProperties[key] : <any>null;
            }
        }
        data["name"] = this.name !== undefined ? this.name : <any>null;
        data["adminEmailAddress"] = this.adminEmailAddress !== undefined ? this.adminEmailAddress : <any>null;
        data["adminPassword"] = this.adminPassword !== undefined ? this.adminPassword : <any>null;
        return data; 
    }
}

export class TenantDto {
    readonly extraProperties!: { [key: string]: any; } | null;
    id!: string;
    name!: string | null;

    init(_data?: any, _mappings?: any) {
        if (_data) {
            if (_data["extraProperties"]) {
                (<any>this).extraProperties = {} as any;
                for (let key in _data["extraProperties"]) {
                    if (_data["extraProperties"].hasOwnProperty(key))
                        (<any>(<any>this).extraProperties)![key] = _data["extraProperties"][key];
                }
            }
            else {
                (<any>this).extraProperties = <any>null;
            }
            this.id = _data["id"] !== undefined ? _data["id"] : <any>null;
            this.name = _data["name"] !== undefined ? _data["name"] : <any>null;
        }
    }

    static fromJS(data: any, _mappings?: any): TenantDto | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<TenantDto>(data, _mappings, TenantDto);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.extraProperties) {
            data["extraProperties"] = {};
            for (let key in this.extraProperties) {
                if (this.extraProperties.hasOwnProperty(key))
                    (<any>data["extraProperties"])[key] = this.extraProperties[key] !== undefined ? this.extraProperties[key] : <any>null;
            }
        }
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["name"] = this.name !== undefined ? this.name : <any>null;
        return data; 
    }
}

export class TenantUpdateDto {
    readonly extraProperties!: { [key: string]: any; } | null;
    name!: string;

    init(_data?: any, _mappings?: any) {
        if (_data) {
            if (_data["extraProperties"]) {
                (<any>this).extraProperties = {} as any;
                for (let key in _data["extraProperties"]) {
                    if (_data["extraProperties"].hasOwnProperty(key))
                        (<any>(<any>this).extraProperties)![key] = _data["extraProperties"][key];
                }
            }
            else {
                (<any>this).extraProperties = <any>null;
            }
            this.name = _data["name"] !== undefined ? _data["name"] : <any>null;
        }
    }

    static fromJS(data: any, _mappings?: any): TenantUpdateDto | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<TenantUpdateDto>(data, _mappings, TenantUpdateDto);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.extraProperties) {
            data["extraProperties"] = {};
            for (let key in this.extraProperties) {
                if (this.extraProperties.hasOwnProperty(key))
                    (<any>data["extraProperties"])[key] = this.extraProperties[key] !== undefined ? this.extraProperties[key] : <any>null;
            }
        }
        data["name"] = this.name !== undefined ? this.name : <any>null;
        return data; 
    }
}

export class UserData {
    id!: string;
    tenantId!: string | null;
    userName!: string | null;
    name!: string | null;
    surname!: string | null;
    email!: string | null;
    emailConfirmed!: boolean;
    phoneNumber!: string | null;
    phoneNumberConfirmed!: boolean;

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.id = _data["id"] !== undefined ? _data["id"] : <any>null;
            this.tenantId = _data["tenantId"] !== undefined ? _data["tenantId"] : <any>null;
            this.userName = _data["userName"] !== undefined ? _data["userName"] : <any>null;
            this.name = _data["name"] !== undefined ? _data["name"] : <any>null;
            this.surname = _data["surname"] !== undefined ? _data["surname"] : <any>null;
            this.email = _data["email"] !== undefined ? _data["email"] : <any>null;
            this.emailConfirmed = _data["emailConfirmed"] !== undefined ? _data["emailConfirmed"] : <any>null;
            this.phoneNumber = _data["phoneNumber"] !== undefined ? _data["phoneNumber"] : <any>null;
            this.phoneNumberConfirmed = _data["phoneNumberConfirmed"] !== undefined ? _data["phoneNumberConfirmed"] : <any>null;
        }
    }

    static fromJS(data: any, _mappings?: any): UserData | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<UserData>(data, _mappings, UserData);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["tenantId"] = this.tenantId !== undefined ? this.tenantId : <any>null;
        data["userName"] = this.userName !== undefined ? this.userName : <any>null;
        data["name"] = this.name !== undefined ? this.name : <any>null;
        data["surname"] = this.surname !== undefined ? this.surname : <any>null;
        data["email"] = this.email !== undefined ? this.email : <any>null;
        data["emailConfirmed"] = this.emailConfirmed !== undefined ? this.emailConfirmed : <any>null;
        data["phoneNumber"] = this.phoneNumber !== undefined ? this.phoneNumber : <any>null;
        data["phoneNumberConfirmed"] = this.phoneNumberConfirmed !== undefined ? this.phoneNumberConfirmed : <any>null;
        return data; 
    }
}

export class IStringValueType {
    readonly name!: string | null;
    readonly properties!: { [key: string]: any; } | null;
    validator!: IValueValidator;

    init(_data?: any, _mappings?: any) {
        if (_data) {
            (<any>this).name = _data["name"] !== undefined ? _data["name"] : <any>null;
            if (_data["properties"]) {
                (<any>this).properties = {} as any;
                for (let key in _data["properties"]) {
                    if (_data["properties"].hasOwnProperty(key))
                        (<any>(<any>this).properties)![key] = _data["properties"][key];
                }
            }
            else {
                (<any>this).properties = <any>null;
            }
            this.validator = _data["validator"] ? IValueValidator.fromJS(_data["validator"], _mappings) : <any>null;
        }
    }

    static fromJS(data: any, _mappings?: any): IStringValueType | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<IStringValueType>(data, _mappings, IStringValueType);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name !== undefined ? this.name : <any>null;
        if (this.properties) {
            data["properties"] = {};
            for (let key in this.properties) {
                if (this.properties.hasOwnProperty(key))
                    (<any>data["properties"])[key] = this.properties[key] !== undefined ? this.properties[key] : <any>null;
            }
        }
        data["validator"] = this.validator ? this.validator.toJSON() : <any>null;
        return data; 
    }
}

export class IValueValidator {
    readonly name!: string | null;
    readonly properties!: { [key: string]: any; } | null;

    init(_data?: any, _mappings?: any) {
        if (_data) {
            (<any>this).name = _data["name"] !== undefined ? _data["name"] : <any>null;
            if (_data["properties"]) {
                (<any>this).properties = {} as any;
                for (let key in _data["properties"]) {
                    if (_data["properties"].hasOwnProperty(key))
                        (<any>(<any>this).properties)![key] = _data["properties"][key];
                }
            }
            else {
                (<any>this).properties = <any>null;
            }
        }
    }

    static fromJS(data: any, _mappings?: any): IValueValidator | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<IValueValidator>(data, _mappings, IValueValidator);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name !== undefined ? this.name : <any>null;
        if (this.properties) {
            data["properties"] = {};
            for (let key in this.properties) {
                if (this.properties.hasOwnProperty(key))
                    (<any>data["properties"])[key] = this.properties[key] !== undefined ? this.properties[key] : <any>null;
            }
        }
        return data; 
    }
}

function jsonParse(json: any, reviver?: any) {
    json = JSON.parse(json, reviver);

    var byid: any = {};
    var refs: any = [];
    json = (function recurse(obj: any, prop?: any, parent?: any) {
        if (typeof obj !== 'object' || !obj)
            return obj;
        
        if ("$ref" in obj) {
            let ref = obj.$ref;
            if (ref in byid)
                return byid[ref];
            refs.push([parent, prop, ref]);
            return undefined;
        } else if ("$id" in obj) {
            let id = obj.$id;
            delete obj.$id;
            if ("$values" in obj)
                obj = obj.$values;
            byid[id] = obj;
        }
        
        if (Array.isArray(obj)) {
            obj = obj.map((v, i) => recurse(v, i, obj));
        } else {
            for (var p in obj) {
                if (obj.hasOwnProperty(p) && obj[p] && typeof obj[p] === 'object')
                    obj[p] = recurse(obj[p], p, obj);
            }
        }

        return obj;
    })(json);

    for (let i = 0; i < refs.length; i++) {
        const ref = refs[i];
        ref[0][ref[1]] = byid[ref[2]];
    }

    return json;
}

function createInstance<T>(data: any, mappings: any, type: any): T | null {
  if (!mappings)
    mappings = [];
  if (!data)
    return null;

  const mappingIndexName = "__mappingIndex";
  if (data[mappingIndexName])
    return <T>mappings[data[mappingIndexName]].target;

  data[mappingIndexName] = mappings.length;

  let result: any = new type();
  mappings.push({ source: data, target: result });
  result.init(data, mappings);
  return result;
}

export class ApiException extends Error {
    message: string;
    status: number;
    response: string;
    headers: { [key: string]: any; };
    result: any;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isApiException = true;

    static isApiException(obj: any): obj is ApiException {
        return obj.isApiException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): any {
    if (result !== null && result !== undefined)
        throw result;
    else
        throw new ApiException(message, status, response, headers, null);
}

function isAxiosError(obj: any | undefined): obj is AxiosError {
    return obj && obj.isAxiosError === true;
}